{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"cover/","title":"Blockchain Protocols and Distributed Applications","text":""},{"location":"cover/#masters-curriculum","title":"Master's Curriculum","text":"<p>Costin Caraba\u0219</p> <p>Politehnica University of Bucharest</p> <p>2025</p> <p>This open textbook is compiled from the course materials in this repository. It is intended for students and practitioners learning modern blockchain systems, smart contracts, dApps, DeFi, and related topics.</p> <p>For the web version, use the sidebar to navigate. For print/PDF, this page serves as the cover.</p> <p>Version: 2025.0 License: Text CC BY-NC-SA 4.0; Code BSD-3-Clause Source: see <code>COPYING.md</code></p>"},{"location":"preface/","title":"Preface","text":"<p>This book consolidates the content used in the BPDA Master's course, aligning labs, slides, and assignments into a single coherent narrative. The goals are:</p> <ul> <li>Provide a structured path from fundamentals to practical development.</li> <li>Offer reproducible, hands-on labs built around MultiversX, Rust, and modern DeFi.</li> <li>Curate references and exercises suitable for self-study and classroom teaching.</li> </ul>"},{"location":"preface/#how-to-read-this-book","title":"How to read this book","text":"<ul> <li>Web: use the left navigation to skim topics and jump between labs and slides.</li> <li>Print/PDF: follow the table of contents; code blocks and figures are adapted for print.</li> </ul>"},{"location":"preface/#acknowledgments","title":"Acknowledgments","text":"<p>Thanks to the contributors, students, and the broader community who inspired and refined these materials.</p>"},{"location":"preface/#feedback","title":"Feedback","text":"<p>Contributions are welcome. Please open issues or pull requests on the repository.</p>"},{"location":"preface/#license","title":"License","text":"<p>Text is licensed under CC BY-NC-SA 4.0; code samples under BSD-3-Clause. See <code>COPYING.md</code> for full terms.</p>"},{"location":"assignments/assignment1/","title":"Trading Card Games","text":""},{"location":"assignments/assignment1/#deadline","title":"Deadline","text":"<ul> <li>20th of November 23:59</li> </ul>"},{"location":"assignments/assignment1/#objective","title":"Objective","text":"<p>The aim of this assignment is to familiarize you with interacting with smart contracts deployed on a blockchain, specifically the MultiversX blockchain. Through this assignment, you will learn how to interact with a deployed smart contract, manage, and exchange  Tradable Cards (Non-Fungible Tokens - NFTs).</p>"},{"location":"assignments/assignment1/#learning-outcomes","title":"Learning Outcomes","text":"<p>By the end of this assignment, students will be able to:</p> <ul> <li>Understand and execute transactions on the MultiversX blockchain;</li> <li>Interact with a deployed smart contract by calling methods using the Python SDK (mxpy tool);</li> <li>Use NFT trading functionality provided by our smart contract;</li> <li>Query on-chain data from our smart contract and interpret results;</li> <li>Gain a better understanding of blockchain concepts while performing a transaction:</li> <li>Private key</li> <li>Gas limit</li> <li>Proxy</li> <li>Nonce</li> </ul>"},{"location":"assignments/assignment1/#overview","title":"Overview","text":"<p>Your job is to create an interactive API over a SC deployed on the MultiversX blockchain. This SC stores a number of NFTs. Each NFT has the following attributes:</p> <ul> <li>class</li> <li>power</li> <li>rarity</li> </ul> <p>In order to solve this assignment you need to provide a way of retrieving and visualizing the available NFTs' data stored in the SC. This should allow a user of your API to then trade a NFT they own with one of the NFTs which is stored inside the contract. This NFT must exactly match the class, power and rarity attributes.</p> <p>A complete flow would look like this.</p> <ul> <li>Through your API, query the SC and see the available NFTs</li> <li>Call the appropriate function from the SC that will return the NFT you should try to trade with. Each NFT has (for example):</li> <li>power: Medium</li> <li>class: Priest</li> <li>rarity: Legendary</li> <li>Let's call it BPDA-NFT</li> <li>Once the contract assigned your BPDA-NFT properties, you need to create your own NFT that must be sent to the contract in order to receive the SC's NFT. Let's call the NFT you have to send Student-NFT</li> <li>In order to receive the BPDA-NFT, the Student-NFT must be created with exactly the same attributes as the BPDA-NFT, otherwise the SC will tell you that the NFT's do not match.</li> <li>Note: the Student-NFT must be named with your moodle account. For example, if your institutional account is cristian.paris@stud.acs.upb.ro, your Student-NFT name is cristian.paris.</li> </ul>"},{"location":"assignments/assignment1/#assignment-tasks","title":"Assignment Tasks","text":""},{"location":"assignments/assignment1/#1-setup-environment","title":"1. Setup Environment","text":"<ul> <li>Set up a MultiversX wallet to be used for devnet interactions (you do not need to create a new wallet if you already have one);</li> <li>Install mxpy (MultiversX tool based on Python SDK) for interacting with the blockchain.</li> <li>Basically, make sure you have done the Setting up the Lab Environment section.</li> <li>It is mandatory to use the Python/Rust/TS/JS/etc SDK to solve the following tasks.</li> </ul>"},{"location":"assignments/assignment1/#2-interacting-with-the-smart-contract","title":"2. Interacting with the Smart Contract","text":"<ul> <li>Smart Contract Address: erd1qqqqqqqqqqqqqpgqrqz7r8yl5dav2z0fgnn302l2w7xynygruvaq76m26j</li> <li>Smart Contract Code: See the assignment for the first homework on GitHub</li> </ul>"},{"location":"assignments/assignment1/#core-interactions","title":"Core Interactions","text":"<ul> <li>Get Your Assigned NFT: Call the <code>getYourNftCardProperties</code> endpoint to receive the properties of the NFT you have to trade with. The properties you receive are hex encoded.</li> <li>Example: Let's say you receive the following hex encoded properties: 020304</li> <li> <p>Each of the bytes corresponds to one of the attributes (class, rarity, power), and they all have the same length. Each byte corresponds to the index of the enum variant of that attribute.</p> </li> <li> <p>Query Smart Contract Data: Query the smart contract for available NFTs and their metadata, parse the metadata and then get the NFT's nonce. You will need the nonce for the exchange part. The nonce is equal to the position of the metadata in the returned list.</p> </li> <li>Note: The vector indexing starts from 1.</li> <li>Function to call: See the <code>nftSupply</code> view function inside the SC.</li> <li>Return: A list of NFTs with details such as token ID, rarity, class, power.</li> <li> <p>Note: Check out this link on how NFT properties are serialized inside the list of returned NFTs.</p> </li> <li> <p>Exchange NFTs: Implement a function to exchange an NFT with another user. This simulates a trading card game scenario where players exchange cards.</p> </li> <li>Function to call: See the <code>exchangeNFT(nonce)</code> inside the SC.</li> <li>Requirements: Make sure the NFT you are going to send has your moodle ID as name and the exact attributes as the one you are trying to trade with.</li> <li>Note: The collection name and other fields are irrelevant.</li> </ul>"},{"location":"assignments/assignment1/#note","title":"Note","text":"<p>You can also deploy the homework's SC for local testing.</p>"},{"location":"assignments/assignment1/#how-do-i-know-if-i-have-successfully-finished-the-homework","title":"How do I know if I have successfully finished the homework?","text":"<p>The homework is done if, at the end of the aforementioned flow, you have a BPDA-TRADING-CARD NFT in your MultiversX wallet. Any further attempts to call the functions <code>getYourNftCardProperties</code> or <code>exchangeNFT</code> will result in a SC error with the following message: Congratulations! You already finished the homework!.</p>"},{"location":"assignments/assignment1/#3-frontend-application-bonus-1","title":"3. Frontend Application (BONUS 1)","text":"<p>Develop a simple front-end (React or other frameworks) that allows users to interact with the smart contract through a web interface.</p> <p>The front-end should:</p> <ul> <li>Display available NFTs.</li> <li>Allow users to trade their NFT with the SC.</li> <li>Show the history of previous trades.</li> </ul>"},{"location":"assignments/assignment1/#4-bug-hunting-bonus-2","title":"4. Bug Hunting (BONUS 2)","text":"<p>Present a reproducible way of exploiting the SC or generating unwanted behavior.</p>"},{"location":"assignments/assignment1/#grading-criteria","title":"Grading Criteria","text":"<ul> <li>Code Functionality (95%): Correct interaction with the smart contract, querying data, and executing NFT exchanges.</li> <li>README (5%): Explanation of contract interactions, NFT trading logic, and challenges faced.</li> <li>Bonus 1 - UI (10%): If a front-end is developed.</li> <li>Bonus 2 - Bug Hunting (10%): During the lab, reproduce the bug or exploit.</li> </ul> <p>Note: The fact that you show the lab assistant the SC NFT inside your wallet is not enough. You will be asked questions based on your code for each task.</p>"},{"location":"assignments/assignment1/#notes","title":"Notes","text":"<ul> <li>Testing: The assignment will be tested on the MultiversX Devnet. Ensure that you use the appropriate network when deploying and interacting with the contract.</li> <li>Collaboration: This is an individual assignment. Each student must submit its own code. Also, each student must present their GitHub during the lab and show that the last changes have been committed before the deadline. You will be asked to clone the repository on the spot.</li> <li>Questions and Help: Please ask any questions on the Forum.</li> </ul>"},{"location":"assignments/assignment1/#useful-resources","title":"Useful Resources","text":"<ul> <li>The official docs</li> <li>Course site</li> </ul>"},{"location":"assignments/assignment2/","title":"Assignment 2","text":"<p>Details TBA.</p>"},{"location":"assignments/blockchain_research_assignment/","title":"Blockchain Research Assignment","text":"<p>The goal of this assignment is to create an essay that does a critical analysis of a blockchain solution: highlighting weak spots and strong spots.</p> <ul> <li>Choose 1 blockchain to compare with MultiversX and Ethereum;</li> <li>Read the whitepapers;</li> <li>Make one 2-3 page essay highlighting the topic in the papers, strengths, weaknesses, alternative approaches, comparison of the papers.</li> </ul> <p>You can search for blockchain on Whitepaper.io. Just click on a coin and then Read Whitepaper.</p> <p>Deadline: Wednesday, 10 January 2024, 11:59 PM</p> <p>Submission link</p>"},{"location":"assignments/project/","title":"Semester Project","text":"<p>The main assignment for this semester is a project on a blockchain. There are no restrictions regarding the blockchain. You can choose one of the idea below or you can create one of your own.</p>"},{"location":"assignments/project/#phase-1-project-idea","title":"Phase 1 - Project Idea","text":"<p>Submit a PDF file containing a description of your idea:</p> <ul> <li>What is the purpose of the project?</li> <li>What needs it tries to satisfy?</li> <li>What are the components of your project?</li> <li>Timeline for development and tasks assignation for each team member.</li> </ul> <p>Each student should submit the PDF file (ex. for a team of 2 students, there will be 2 submissions). Keep it brief. 1 page is enough; hard cap is 2 pages.</p> <p>Submission link Deadline: Monday, 16 December 2024, 11:59 PM</p>"},{"location":"assignments/project/#phase-2-project-documentation","title":"Phase 2 - Project documentation","text":"<p>Submit a PDF file containing:</p> <ul> <li>Description of your project;</li> <li>Includes links to the github repo;</li> <li>Documentation you used;</li> <li>Documentation you wrote.</li> </ul> <p>Each student should submit the PDF file (ex. for a team of 2 students, there will be 2 submissions).</p> <p>Submission link Deadline: Monday, 13 January 2024, 11:59 PM</p>"},{"location":"assignments/project/#phase-3-project-presentation","title":"Phase 3 - Project presentation","text":"<p>During the lecture &amp; practical session you will have the chance to demo your project.</p>"},{"location":"assignments/project/#questions-and-considerations","title":"Questions and considerations","text":"<ul> <li>You can do the project by yourself or in a team of two.</li> <li>There are no minimum requirements. You can do a dApp, a VSCode tool that helps blockchain development, or a GitHub CI solution that helps the development process. Be creative;</li> <li>There are no blockchain restrictions. You can use whatever blockchain solution you want.</li> </ul>"},{"location":"assignments/project/#list-of-ideas","title":"List of ideas","text":"<p>You can choose one of the idea below or you can create one of your own.</p>"},{"location":"assignments/project/#infrastructure-developers-tooling","title":"Infrastructure &amp; Developers Tooling","text":"Idea name Description Cross chain Bridge build a cross-chain bridge that enables the secure and seamless transfer of assets between different blockchain networks, enhancing interoperability and expanding the utility of blockchain ecosystems. Wallet as a service create a solution so that companies can seamlessly integrate wallet functionalities directly into their applications, simplifying user onboarding to the ease of a username and password. Whether facilitating in-game asset trading for gamers or pioneering innovative token-based loyalty programs, WaaS represents a potent resource for enterprises seeking to unlock the full potential of the web3 ecosystem. Data analytics create data analytics tools and platforms tailored for blockchain and DeFI data, offering insights, visualization, and predictive analytics to empower developers and users. Decentralized storage solution design a decentralized storage solution that leverages blockchain technology for secure and distributed data storage, catering to the needs of decentralized applications and services. Gas profiling tool developing a gas profiling tool that helps Multiversx developers optimize gas usage in their smart contracts, reducing transaction costs and enhancing overall efficiency. Digital identity solution create a decentralized digital identity solution that allows users to manage and control their identities securely, offering privacy and data ownership in the digital realm. Smart contract simulator build a smart contract simulator that enables developers to test and analyze the behavior of their smart contracts in various scenarios before deploying them on the blockchain, enhancing code reliability. EVM compatible shard develop an Ethereum Virtual Machine (EVM)-compatible shard Blockchains for everybody Not everybody owns a smart phone or a laptop. How can they interact with the blockchain?"},{"location":"assignments/project/#mobile-apps","title":"Mobile Apps","text":"Idea name Description Multi-chain Wallet Develop a cross chain user-friendly mobile wallet app that allows users to store, manage, and transact with cryptocurrencies securely. The app should also support decentralized applications (DApps) and DeFi services. Tokenized Digital Collectibles create a mobile app that specializes in collecting, trading, and showcasing blockchain-based digital collectibles and NFTs. Users would be able to explore, discover, and interact with a wide range of digital art, assets, and unique collectibles, all securely stored on the blockchain. The app would offer features such as buying, selling, and trading NFTs, creating an engaging platform for collectors and enthusiasts to connect and showcase their prized digital possessions. Fitness companion utilizes blockchain for secure data storage, tokenized rewards, and decentralized fitness challenges, creating a motivating and privacy-focused ecosystem for users to achieve their fitness goals. Users can also make seamless cryptocurrency payments to fitness professionals and collect fitness-related NFTs to celebrate their accomplishments within the community. NFT Ticket master mobile app that disrupts traditional ticketing by using blockchain and NFTs. It empowers event organizers to issue verifiable and tradable NFT-based tickets, enhancing security and ownership, while attendees enjoy the convenience of secure mobile ticketing and a resale marketplace for tickets. Quest Master mobile app that lets groups of three or more users create and join challenges, with each participant contributing tokens to a prize pool. To claim the prize, all participants must reach a consensus that a task has been successfully completed, creating a fun and interactive way to collaborate and compete while using blockchain for transparency and rewards Tokenized Real Estate Investment Platform An app that democratizes real estate investment by allowing users to invest in fractional ownership of properties using blockchain tokens. Users can buy, sell, and trade real estate tokens, making property investment more accessible. Crypto Savings and Investment App A user-friendly mobile app that simplifies cryptocurrency savings and investments. It could offer features like automated recurring investments, yield farming, and tracking portfolios, all while utilizing blockchain for transparency and security. Blockchain-Backed Supply Chain Tracker An app that allows consumers to trace the journey of products from the source to their hands. Users can scan QR codes to access information about the product's origin, quality, and authenticity, all recorded on the blockchain. Blockchain-Powered Voting App A mobile app for secure and transparent voting in elections, referendums, or decision-making processes. Blockchain technology ensures the integrity of votes and provides accessible and verifiable election results. Blockchain-Powered Voting App An app that connects freelancers and clients on a blockchain platform. Smart contracts ensure secure and automatic payment upon project completion, and reputation systems build trust within the freelance community."},{"location":"assignments/project/#artificial-intelligence","title":"Artificial Intelligence","text":"Idea name Description Smart IDE's IDE that incorporates advanced AI capabilities to enhance the coding experience. This intelligent IDE provides real-time code assistance, predictive suggestions, bug detection, code optimization, and even supports real-time collaboration, significantly improving developer productivity and code quality. It's a powerful tool that leverages AI to make coding more efficient, intuitive, and collaborative. AI-Powered documentation The IDE generates documentation and comments based on code, making it easier to maintain and understand codebases. Security Analysis AI algorithms continuously analyze code for potential vulnerabilities and provide security recommendations. Code Generation The IDE can generate boilerplate code, common functions, and even entire code segments based on high-level descriptions or user requirements, speeding up the development process. Generative AI in games integrate advanced AI algorithms that dynamically generate game content, such as levels, characters, and narratives. This innovation creates ever-changing and immersive gaming experiences, providing players with endless challenges and adventures, all driven by the power of AI. AI agents interactions a product where AI-powered agents autonomously handle and optimize various types of blockchain transactions, including transfers of assets, smart contract executions, and consensus participation. These AI agents enhance the efficiency, security, and reliability of blockchain interactions, enabling a new and innovative way to study blockchains interactions and why not testing principles. Chain behavior predictions Build an AI-driven platform that predicts the behavior of various blockchain networks based on historical data and current trends. Users can leverage these predictions to make informed decisions when participating in cross-chain transactions or asset swaps. 3D Generated worlds The integration of blockchain technology ensures secure ownership of digital assets, including virtual land, creatures, and resources, empowering users to explore, interact, trade, and collaborate within this vibrant and blockchain-enhanced 3D universe."},{"location":"assignments/project/#payments","title":"Payments","text":"Idea name Description Micropayments Explore groundbreaking solutions that leverage blockchain technology to enable microtransactions. You will delve into the possibilities of frictionless, low-cost micropayments for various use cases, such as content monetization, pay-as-you-go services, and micro-donations Scheduled payments Develop blockchain-based solutions that enable automated and scheduled transactions. You will explore innovative ways to leverage blockchain technology for seamless and secure scheduled payments, benefiting a wide range of applications, from recurring bills and salary payments to subscription services. Fund raising platforms Design blockchain-powered fundraising platforms that redefine how funds are raised, tracked, and allocated for various causes. By leveraging blockchain's transparency and security, you can create efficient, decentralized solutions that enhance the fundraising process and foster trust among donors and fundraisers, ultimately driving social impact and positive change Cross-Chain payments This idea aims to bridge the gap between different blockchain networks, allowing users to seamlessly transfer and transact digital assets across multiple blockchains. This idea seeks to simplify the process of conducting cross-chain transactions, enhancing interoperability and accessibility in the blockchain ecosystem. It holds the potential to revolutionize the way we move and use cryptocurrencies and tokens across various blockchain platforms, ultimately making blockchain technology more versatile and user-friendly. No-Code solution for grandmas and grandpas This idea challenges you to create a no-code blockchain interaction solution that is so user-friendly it can be effortlessly used by individuals of all ages and backgrounds. The primary focus is to streamline the onboarding process for merchants, enabling them to accept MVX tokens with ease through features like simplified wallet setup, integrated point-of-sale systems, and user-friendly interfaces. By fostering inclusivity and accessibility, you can envision a future where blockchain technology is as accessible as everyday mobile devices, revolutionizing the way we engage with digital assets. Fast pay solutions This idea challenges you to revolutionize digital payments by seamlessly integrating QR code scanning with blockchain technology, offering innovative solutions that prioritize user-friendliness and security. This track empowers you to shape the future of financial transactions, bridging the gap between traditional payment methods and the decentralized world of blockchain, ultimately enhancing accessibility and usability for users worldwide. Payments for all tokens What if you have USDC and the merchants accepts only BUSD? Come up with a solution without the need to go through the additional step of converting their tokens on a swapping platform before finalizing their payment for the intended purchase. NFT Payments solutions Explore ways to integrate non-fungible tokens (NFTs) into payment systems. You should devise a payment solution that incorporates NFTs for unique, valuable, or collectible transactions. Programmable money \"Although money itself isn't inherently programmable, its full potential can be unlocked through automation and purpose-built tools. This presents an opportunity to create open-source, fee-free, and publicly accessible programs that can harness the power of money and on-chain tokens more effectively. For example: Facilitating the seamless processing of invoices within a smart contract filled with funds. Person A submits an invoice, and person B can sign an approval transaction to release the funds to the appropriate recipient.\" Loyalty and Rewards Programs Create a blockchain-based loyalty and rewards program that allows businesses to issue and manage loyalty points or tokens on a blockchain. You should focus on enhancing customer engagement and retention."},{"location":"assignments/project/#gaming-and-metaverse","title":"Gaming and Metaverse","text":"Idea name Description Blockchain Gaming Economy Description: Develop a comprehensive blockchain-based gaming economy that integrates cryptocurrencies, non-fungible tokens (NFTs), and decentralized exchanges. This challenge involves designing in-game assets, marketplaces, and economic systems that empower players to buy, sell, and trade virtual items and currency securely on the blockchain. Decentralized Game Development Description: Create a decentralized game development platform that allows game creators to collaborate transparently while utilizing blockchain technology for asset ownership and revenue sharing. This challenge encourages teams to design tools and frameworks that foster a community-driven approach to game creation. Blockchain-Based Game Verification Description: Build a system or tool that verifies the authenticity of in-game assets by utilizing blockchain technology. This verification system should ensure that assets, such as characters, weapons, or collectibles, are legitimate and cannot be tampered with, enhancing player trust and security. In-game advertising platform Description: Construct an innovative in-game advertising platform that seamlessly integrates advertisements into gaming experiences. This platform should offer targeted and non-disruptive advertising solutions that benefit both advertisers and players while ensuring transparency and fair compensation for developers. Generative AI in a game Description: Integrate generative artificial intelligence (AI) techniques into a game to dynamically generate content such as levels, quests, or narratives. You should leverage AI algorithms to create engaging and ever-evolving gaming experiences that adapt to player behavior. Generative AI in trailers/videos/tutorials Description: Utilize generative AI to automate the creation of game trailers, promotional videos, or tutorial content. This challenge encourages You to develop AI systems that can efficiently generate high-quality multimedia content for games and user guidance purposes. Game Plugins Description: Design and develop a set of plugins or extensions for existing game engines or platforms. These plugins should enhance game development workflows, improve performance, or add new features, making it easier for developers to create games across various genres. Sample games Description: Create sample games that serve as templates or starting points for aspiring game developers. These games should cover different genres and showcase best practices in game design, coding, and user experience. Game templates Description: Develop a library of game templates that provide pre-designed frameworks for specific game types or mechanics. These templates should include customizable assets, code templates, and documentation, enabling developers to kickstart their game projects more efficiently."},{"location":"assignments/scientific_research_assignment/","title":"Scientific Research Assignment","text":"<p>The goal of this assignment is to create a 2-3 page essay that does a critical analysis of a research topic. Your task is to highlight weak spots and strong spots for each paper.</p> <p>Deadline: Wednesday, 10 January 2024, 11:59 PM</p> <p>Submission link</p> <p>You can start from one of the topics below, or propose a new one. We encourage you to find 2-3 similar papers on Google Scholar related to your chosen topic.</p> Paper Name Link Proof of Space with VDF: An Alternative Permissionless BFT Consensus Protocol, by Yuxuan Luo. Link An Initial Framework for NFT Auction Mechanism Design: Impossibility Results and Solutions, by Andy Arditi, Pranav Garimidi, Dean Hirsch, and Iason Milionis. Link Alternative Sybil Resistance Methods, by Marcus Daly, Nathan Cuevas, Griffin Klett, and Lynn Zhu. Link A Review of Zero Knowledge Proofs, by Thomas Chen, Abby Lu, Jern Kunpittaya, and Alan Luo. Link A Survey of DeFi Lending, by Alex Brenebel, Lynsey Haynes, Vaibhav Kapur, and Jonathan Larkin. Link DAOs, by Utkarsh Sinha, Sofia Bianchi, Ian Macleod, and Imanol Uribe. Link Proof of Participation Voting for On-Chain Governance, by Terry Chung, Sandip Nair, Uttara Ravi, and Pranav Kajgaonkar. Link A Technical Deep Dive Into and Implementation of Non-Fungible Tokens in a Practical Setting, by Julia Martin and Carrie Hay Kellar. Link Privacy when Everyone is Watching: Anonymity on the Blockchain, by Nilaksh Agarwal and Roy Rinberg. Link MEV on L2 by FlashBabies (Huy Ha, Vasiliki Vlachou, Quintus Kilbourn, and Cesare De Michellis). Link"},{"location":"chapters/","title":"Blockchain Protocols and Distributed Applications","text":"<p>Welcome to the course on Blockchain Protocols and Distributed Applications. This course will provide you with a comprehensive understanding of blockchain technology and its applications in various domains.</p>"},{"location":"chapters/#course-overview","title":"Course Overview","text":"<p>In this course, you will explore the following key topics:</p> <ul> <li>Introduction to Blockchain Technology</li> <li>Blockchain Protocols and Consensus Mechanisms</li> <li>Virtual Machines in Blockchains</li> <li>Wallets</li> <li>Smart Contracts</li> <li>DApps (Decentralized Applications)</li> <li>Security in Blockchains</li> <li>MultiversX and Rust Programming</li> <li>Blockchain Use Cases in Finance and more</li> </ul>"},{"location":"chapters/#prerequisites","title":"Prerequisites","text":"<p>While there are no strict prerequisites for this course, a basic understanding of computer science and programming concepts will be beneficial.</p>"},{"location":"chapters/#who-should-take-this-course","title":"Who should take this course?","text":"<ul> <li>Students interested in blockchain technology and its applications.</li> <li>Developers and professionals looking to enhance their skills in blockchain development.</li> <li>Anyone curious about the future of decentralized and secure systems.</li> </ul>"},{"location":"chapters/composability/lab/content/","title":"Composability / DeFi","text":""},{"location":"chapters/composability/lab/content/#bridges","title":"Bridges","text":""},{"location":"chapters/composability/lab/content/#dex","title":"DEX","text":""},{"location":"chapters/composability/lab/content/#lendingborrowing","title":"Lending/Borrowing","text":""},{"location":"chapters/composability/lab/content/#oracles","title":"Oracles","text":""},{"location":"chapters/ctf/bump/","title":"CTF Bump","text":"<p>Let's see who can bump the most!</p> <p>Participants are asked to call <code>bump</code> as many times as possible. Each <code>bump</code> increases the score by one.</p> <p>It is also possible to donate your bumps, if you're feeling generous (or if you used a smart contract to harvest more bumps).</p> <pre><code>#[multiversx_sc::contract]\npub trait CtfBump: bump_common::BumpCommon {\n    #[init]\n    fn init(&amp;self) {}\n\n    #[upgrade]\n    fn upgrade(&amp;self) {}\n\n    #[endpoint]\n    fn bump(&amp;self) {\n        let caller = self.blockchain().get_caller();\n        self.perform_bump(&amp;caller);\n    }\n\n    fn perform_bump(&amp;self, bumper: &amp;ManagedAddress) {\n        self.bumps(bumper).update(|bumps| *bumps += 1u32);\n    }\n\n    #[endpoint(donateBumps)]\n    fn donate_bumps(&amp;self, receiver: ManagedAddress) {\n        let caller = self.blockchain().get_caller();\n        let caller_bumps = self.bumps(&amp;caller).take();\n        self.bumps(&amp;receiver).update(|bumps| *bumps += caller_bumps);\n    }\n\n    #[view]\n    #[storage_mapper(\"bumps\")]\n    fn bumps(&amp;self, bumper: &amp;ManagedAddress) -&gt; SingleValueMapper&lt;BigUint&gt;;\n}\n</code></pre>"},{"location":"chapters/ctf/coinflip/","title":"CTF Coinflip","text":"<p>Let's see who can get the highest score!</p> <p>The rules are as follows: - You call coinflip. - The contract flips a coin, your odds of being lucky are 50/50. - If you are lucky, you get 1 point. - If you are unlucky, your score is reset to zero.</p> <p>You can rely on sheer brute-force, but some of you will notice that the \"randomness\" function is not exactly bulletproof.</p> <p>Best of \"luck\"!</p> <p>Here is the code that is executed: <pre><code>    #[endpoint]\n    fn coinflip(&amp;self) -&gt; bool {\n        let lucky = self.flip_coin();\n        let caller = self.blockchain().get_caller();\n        if lucky {\n            self.perform_bump(&amp;caller);\n        } else {\n            let caller = self.blockchain().get_caller();\n            self.bumps(&amp;caller).clear();\n        };\n        self.coinflip_event(&amp;caller, lucky);\n        lucky\n    }\n\n    fn flip_coin(&amp;self) -&gt; bool {\n        let block_nonce = self.blockchain().get_block_nonce();\n        block_nonce &amp; 1 == block_nonce &amp; 2\n    }\n\n    fn perform_bump(&amp;self, bumper: &amp;ManagedAddress) {\n        self.bumps(bumper).update(|bumps| *bumps += 1u32);\n    }\n\n    #[view]\n    #[storage_mapper(\"bumps\")]\n    fn bumps(&amp;self, bumper: &amp;ManagedAddress) -&gt; SingleValueMapper&lt;BigUint&gt;;\n</code></pre></p>"},{"location":"chapters/ctf/ctf/","title":"Capture the flag","text":"<p>Let's see who can get the highest score!</p> <p>This repo contains 3 challenges: 1. Bump 2. Coinflip 3. GasPass</p> <p>All these challenges can be completed using nothing but Rust interactors and smart contracts, but of course, you are free to use any technology you prefer.</p>"},{"location":"chapters/ctf/ctf/#setup","title":"Setup","text":"<p>Make sure to have your own account, then communicate to the team which one is your wallet.</p> <p>The challenge contracts are already deployed to devnet:</p> <pre><code>gateway = 'https://devnet-gateway.multiversx.com'\nbump_address = \"erd1qqqqqqqqqqqqqpgqnqw2aep56p5hg5ksualpfwav55pvaafjd8ssg4pur0\"\ncoinflip_address = \"erd1qqqqqqqqqqqqqpgqmzaphnyv5gs0jkvr6sywtynj0s3a53rnd8ss29w0hr\"\ngaspass_address = \"erd1qqqqqqqqqqqqqpgquvpnteagc5xsslc3yc9hf6um6n6jjgzdd8ss07v9ma\"\n</code></pre> <p>Best of luck!</p>"},{"location":"chapters/ctf/gaspass/","title":"CTF GasPass","text":"<p>Let's see who can get at least one point!</p> <p>There is one obstacle, though: you must provide the exact value for gas to get even one single point. What should this value be?</p> <p>Brute force is always an option, but maybe some of you will find a quicker way?</p> <p>Once you get the correct value for gas, the problem becomes identical to <code>bump</code>, so 1 point in this round is enough to prove your worth!</p> <p>For this challenge you will get the full code: <pre><code>#[multiversx_sc::contract]\npub trait CtfGaspass: bump_common::BumpCommon {\n    #[init]\n    fn init(&amp;self) {}\n\n    #[upgrade]\n    fn upgrade(&amp;self) {}\n\n    #[endpoint]\n    fn gaspass(&amp;self) -&gt; bool {\n        let gas_left = self.blockchain().get_gas_left();\n        let caller = self.blockchain().get_caller();\n        let the_key = KEY_BASELINE + self.personal_key(&amp;caller);\n        let passed = gas_left == the_key;\n\n        if passed {\n            self.perform_bump(&amp;caller);\n        } else {\n            self.bumps(&amp;caller).clear();\n        };\n        self.gaspass_event(&amp;caller, passed);\n        passed\n    }\n\n    fn personal_key(&amp;self, caller: &amp;ManagedAddress) -&gt; u64 {\n        let bytes = caller.to_byte_array();\n        bytes.iter().map(|&amp;b| b as u64).sum()\n    }\n\n    #[event(\"gaspass\")]\n    fn gaspass_event(&amp;self, #[indexed] caller: &amp;ManagedAddress, #[indexed] passed: bool);\n\n    fn perform_bump(&amp;self, bumper: &amp;ManagedAddress) {\n        self.bumps(bumper).update(|bumps| *bumps += 1u32);\n    }\n\n    #[view]\n    #[storage_mapper(\"bumps\")]\n    fn bumps(&amp;self, bumper: &amp;ManagedAddress) -&gt; SingleValueMapper&lt;BigUint&gt;;\n}\n</code></pre></p> <p>Enjoy your hacking!</p>"},{"location":"chapters/dApps/lab/content/dApp/","title":"Decentralized Applications","text":""},{"location":"chapters/dApps/lab/content/dApp/#objectives","title":"Objectives:","text":"<ul> <li>In this lab you will build your first decentralized application (dApp);</li> <li>You will create a ping pong application where you will:<ul> <li>Create a User Interface (template provided);</li> <li>Login via private key (pem, Chrome extension);</li> <li>Create a Smart contract (template provided);</li> <li>Interact with the User Interface and observe the blockchain transaction;</li> </ul> </li> </ul>"},{"location":"chapters/dApps/lab/content/dApp/#dapp-description","title":"dApp Description","text":"<p>The Ping-Pong app is a very simple decentralized application that will allow the user to deposit a specific number of tokens to a smart contract address and to lock them for a specific amount of time. After this time interval passes, the user can claim back the same amount of tokens.</p> <p>Sending funds to the contract is called ping.</p> <p>Claiming the same amount back is called pong.</p> <p></p>"},{"location":"chapters/dApps/lab/content/dApp/#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have the following: - <code>stable</code> Rust version <code>\u2265 1.78.0</code> (install via rustup) - <code>multiversx-sc-meta</code> (cargo install multiversx-sc-meta) - <code>Node.js</code> with version <code>\u2265 18</code>(guide here) - <code>yarn</code> (npm install --global yarn )</p> <p>We are going to use <code>sc-meta</code> to: 1. Create a wallet to handle your transactions. 2. Build and deploy a contract. </p>"},{"location":"chapters/dApps/lab/content/dApp/#dapp-architecture","title":"dApp architecture","text":""},{"location":"chapters/dApps/lab/content/dApp/#application-layer-the-frontend","title":"Application Layer (The Frontend)","text":"<p>For the web app we'll have two pages:</p> <ul> <li>The Sign-in page - here we can authenticate with ledger, web wallet or with xPortal app</li> <li>The Dashboard page - here we can either ping or pong, if we have already deposited, then we will see a countdown timer until the time interval clears.</li> </ul>"},{"location":"chapters/dApps/lab/content/dApp/#blockchain-layer-the-backend","title":"Blockchain Layer (The Backend)","text":"<p>We will create a smart contract that can handle: - <code>ping</code>: user sends some EGLD to be locked in the contract for a period of time; - <code>pong</code>: user can take back funds from the contract; - <code>pongAll</code>: all users who deposited can take back funds from the contract; - <code>getUserAddresses</code>: view that lists the addresses of all users that have <code>ping</code>-ed in the order they have <code>ping</code>-ed; - <code>getContractState</code>: view that returns the current contract state as a ContractState structure; - <code>getPingAmount</code>: storage mapper that saves the total EGLD deposit; - <code>getDeadline</code>: storage mapper that saves the amount of time until the EGLD is deposited; - <code>activationTimestamp</code>: storage mapper that saves the timestamp of the block where the contract got activated. If it is not specified in the constructor it is the deploy block timestamp. - <code>maxFunds</code>: storage mapper that saves the funding limit if it was set in init.  - <code>user</code>: storage mapper that saves information about the user who deposited.  - <code>userStatus</code>: storage mapper that saves the state of user funds:   - 0 - user unknown, never <code>ping</code>-ed;   - 1 - <code>ping</code>-ed;   - 2 - <code>pong</code>-ed. - <code>pongAllLastUser</code>: storage mapper that saves the completion status of the last user. It is part of the <code>pongAll</code> status. It stores:     - <code>0</code> if <code>pongAll</code> was never called;     - the index of the last user. - <code>ping_event</code>: event that signals a successful <code>ping</code> by the user with amount; - <code>pong_event</code>: event that signals a successful <code>pong</code> by the user with amount; - <code>pong_all_event</code>: event that signals the beginning of the <code>pongAll</code> operation, status and last user.</p> <p>Let's say that, for now, this smart contract plays the role of an API in a dApp. Also, this is where our business logic resides.</p> <p>The MultiversX devnet is a public test network maintained by our community where any developer can test their smart contracts and dApps in a real world environment.</p>"},{"location":"chapters/dApps/lab/content/dApp/#set-up-the-environment","title":"Set up the environment","text":"<p>Let's set up the environment for getting your first dapp up and running.</p>"},{"location":"chapters/dApps/lab/content/dApp/#project-structure","title":"Project Structure","text":"<p>First let's create a new folder for our project, I'll name it <code>ping-pong</code>.</p> <pre><code>mkdir -p ping-pong/wallet\ncd ping-pong\n</code></pre> <p>In the end, we will have three subfolders: wallet, contract and dapp. For convenience, we'll save our owner's PEM wallet in the wallet folder.</p> <p></p>"},{"location":"chapters/dApps/lab/content/dApp/#create-the-owner-wallet","title":"Create the owner wallet","text":"<p>The smart contract can only be deployed on the blockchain by an owner, so let's create an owner's wallet PEM file. The owner can also update the contract, later on, if needed. Keep in mind we only use PEM wallets for testing and playing around with non-production code. For real applications please follow best practices, use secure wallets that can be generated here.</p> <p>First, make sure you are in the <code>ping-pong</code> folder.</p> <pre><code>sc-meta wallet new --format pem --outfile ./wallet/wallet-owner.pem\n</code></pre> <p>In order to initiate transactions on the blockchain, we need some funds, every transaction costs a very small fee, on the blockchain this is called gas.</p> <p>On the devnet wallet we have a faucet that allows you to get free test funds for our applications. You can log in with your PEM using the newly generated PEM file. Use the faucet from the menu as you see below and you are all set.</p>"},{"location":"chapters/dApps/lab/content/dApp/#the-blockchain-layer-the-smart-contract","title":"The Blockchain Layer - The Smart Contract","text":"<p>Our owner wallet is completely set now, we can move on to our backend, the blockchain layer.</p>"},{"location":"chapters/dApps/lab/content/dApp/#clone-the-template","title":"Clone the template","text":"<p>Let's start with our smart contract. We'll first clone the Ping-Pong sample contract repository from here.</p> <p>Also make sure you are still in the ping-pong folder.</p> <pre><code>git clone https://github.com/multiversx/mx-ping-pong-sc contract\n</code></pre>"},{"location":"chapters/dApps/lab/content/dApp/#build-the-smart-contract","title":"Build the Smart Contract","text":"<p>We now have the source code for the smart contract, but we need to compile it into a binary that the MultiversX Virtual Machine can run. The VM can run Web Assembly code, so we need to compile our Rust source code into Web Assembly (WASM).</p> <p>Run the following command in order to build the rust smart contract into a wasm file.</p> <pre><code>cd contract/ping-pong\nsc-meta all build\n</code></pre> <p>When running the build command, a WASM file gets created: <code>output/ping-pong.wasm</code>. This file contains the bytecode of our smart contract.</p>"},{"location":"chapters/dApps/lab/content/dApp/#customize-and-deploy","title":"Customize and Deploy","text":"<p>Next step is to deploy the smart contract to the blockchain.</p> <p>Make sure <code>wallet_owner.pem</code> is in the right folder, the smart contract is built and let's get to the deployment. For now let's continue with the default values.</p> <p>At path <code>contract/ping-pong/interactor</code> we will run:</p> <pre><code>cargo run deploy --ping-amount 5 --duration-in-seconds 3000\n</code></pre> <p>We'll take a look at the log output. We have 2 elements that need our attention: the contract address and the transaction hash. Let's check them in the Devnet Explorer.</p> <p>Devnet Explorer will be your best friend in developing dApps on the MultiversX Blockchain, as you'll first deploy and test your dApps on Devnet.</p> <pre><code>    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.09s\n    Running `/ping-pong/contract/target/debug/ping-pong-interact deploy --ping-amount 5 --duration-in-seconds 30`\nwallet address: erd1z32fx8l6wk9tx4j555sxk28fm0clhr0cl88dpyam9zr7kw0hu7hsx2j524\nsender's recalled nonce: 2792\n-- tx nonce: 2792\nsc deploy tx hash: dff1a89781fa99a9d58bdef64d7c5ed08a18cb4366a90d15d0d8e324bef1ff46\ndeploy address: erd1qqqqqqqqqqqqqpgq4c7tawwwuw8trvf7vx2g48h6tc36u42nqqes9caejv\nnew address: serd1qqqqqqqqqqqqqpgq4c7tawwwuw8trvf7vx2g48h6tc36u42nqqes9caejv\n</code></pre> <p>The smart contract is now deployed on the blockchain. We can interact with it using blockchain transactions in order to invoke smart contract functions <code>ping</code> or <code>pong</code>.</p> <p>The smart contract source code resides in <code>ping-pong/contract/ping-pong/src/ping_pong.rs</code>.</p> <p>There are two main functions: <code>ping</code>, <code>pong</code> and <code>pongAll</code> these are invoked using blockchain transactions.</p> <p>We also have other functions defined in the smart contract: <code>getUserAddresses</code>, <code>getContractState</code>, <code>getPingAmount</code>, <code>getDeadline</code>, <code>getActivationTimestamp</code>, <code>getMaxFunds</code>, <code>getUserStatus</code> and <code>pongAllLastUser</code>. These functions are views and are invoked using the MultiversX API.</p>"},{"location":"chapters/dApps/lab/content/dApp/#the-application-layer-the-web-app","title":"The Application Layer - The Web App","text":"<p>All right, let's move on to the application layer.</p>"},{"location":"chapters/dApps/lab/content/dApp/#clone-the-sample-app","title":"Clone the Sample App","text":"<p>First make sure to go back to the root <code>ping-pong</code> folder.</p> <p>We will clone a very simple dApp template that implements the calls to our newly deployed smart contract.</p> <pre><code>git clone https://github.com/multiversx/mx-template-dapp dapp\ncd dapp\n</code></pre>"},{"location":"chapters/dApps/lab/content/dApp/#configure-the-app","title":"Configure the app","text":"<p>Use the preferred editor and customize the Smart Contract Address located in <code>src/config/config-devnet.tsx</code></p> <p>Then edit this instruction, and change it to the contract address that was shown in the previous step.</p> <p></p>"},{"location":"chapters/dApps/lab/content/dApp/#build-the-dapp","title":"Build the dApp","text":"<p>Please make sure you have yarn installed on your machine.</p> <p>At path <code>ping-pong/dapp</code> we will install the dependencies:</p> <pre><code>npm install --global yarn\nyarn add vite --dev\n</code></pre> <p>Then we will start a development server to test our new dApp:</p> <pre><code>yarn start:devnet\n</code></pre> <p>Run it on local machine (or host it on your server) If you start the development server on the local machine, then open https://localhost:3000 in your browser.</p> <p>If you start it on your own server, then you can access http://ip:3000. The built version only contains static files, so any hosting provider will do.</p> <p>After you start the development server, when you see the Template dApp screen, this means the application is up and running.</p> <p></p>"},{"location":"chapters/dApps/lab/content/dApp/#try-your-application","title":"Try your Application","text":"<p>We will sign in with a test wallet.</p> <p>To do this, we will press Connect button and choose Web Wallet option.</p> <p></p> <p>After you access Web Wallet connection, you will be forwarded to login on Multiversx Wallet.</p> <p></p> <p>You will choose PEM option to login. You can reuse the same owner's wallet if you want to, or an old one.</p>"},{"location":"chapters/dApps/lab/content/dApp/#ping-feature","title":"Ping Feature","text":"<p>After signing in, we'll see the dashboard where we can see the Ping button.</p> <p>Click the Ping button and you'll be redirected to the authentication page on the web wallet.</p> <p></p> <p>A new transaction will be created and you'll be asked to confirm it. This transaction transfers balance from your wallet to the smart contract address. Those funds will be locked for the specified period of time. Pay attention to the data field, where we call the smart contract function <code>ping</code>.</p> <p>After you confirm the transaction, a success message will appear and the funds are locked.</p> <p>Wait the time interval You can see the amount of time you'll have to wait until you can pong.</p>"},{"location":"chapters/dApps/lab/content/dApp/#pong-feature","title":"Pong Feature","text":"<p>After the time interval has passed, you can claim the funds by clicking the Pong button. Another blockchain transaction will wait to be processed, this time the amount will be zero, as we only have to invoke the <code>pong</code> function (specified in the data field). The transaction will trigger a success message and the funds will be returned to the wallet.</p>"},{"location":"chapters/introduction/lab/content/explorer/blocks/","title":"Blocks in Blockchain","text":"<p>For simplicity, we will use MultiversX blockchain and MultiversX Explorer.</p>"},{"location":"chapters/introduction/lab/content/explorer/blocks/#notarization-of-blocks","title":"Notarization of blocks","text":"<p>Inspect the image below: </p> <p>We can observe 4 blocks from 1 second ago for 4 different shards: Shard0, Shard1, Shard2, Metachain. These shard a sub-blockchains and enables MultiversX to scale. You can read more about shard here.</p> <p>We can observe 4 more blocks from 7 seconds ago. That's because each shard outputs a block every 6 seconds.</p> <p>NOTE</p> <p>We previously saw that every 6 seconds starts new round, but not necessarily a new block gets notarized. In this case all the blocks successfully passed the consensus round and got notarized.</p>"},{"location":"chapters/introduction/lab/content/explorer/blocks/#block-details","title":"Block details","text":"<p>Here is the link for one of the blocks in the previous image (Block Height: 16826695).</p> <p></p> <p>Observe the block details: - Round - Epoch - Age (timestamp) - Shard</p> <p>Based on a simple calculus, the epoch is 1168 which means this blockchain started 3 years and 73 days ago.</p> <p>We will talk about the other fields in the next section.</p>"},{"location":"chapters/introduction/lab/content/explorer/blocks/#practice","title":"Practice","text":"<ol> <li>Go to the MultiversX Explorer and check more blocks from different shard;</li> <li>Go to the Ethereum Explorer and check some blocks details.</li> </ol>"},{"location":"chapters/introduction/lab/content/explorer/consensus/","title":"Consensus Group","text":"<p>We will continue with the same block from the previous section (Block Height: 16826695).</p> <p>Observe the field Consensus Group: </p> <p>There are 63 validators which execute every transaction in this block. If you click on the 63 validators (See all) button you will see 63 public keys, which are links to all the 63 nodes that participated in consensus.</p>"},{"location":"chapters/introduction/lab/content/explorer/consensus/#practice","title":"Practice","text":"<ul> <li>Open 3 different blocks in 3 different tabs. Observe that every time there is another consensus group. Why do you think the system is designed this way?</li> <li>Open 3 different blocks in 3 different tabs on Ethereum Explorer. Observe that every time there is another leader.</li> </ul>"},{"location":"chapters/introduction/lab/content/explorer/devnet_testnet/","title":"Devnet &amp; Testnet Blockchain","text":"<p>While developing applications, there is a need for a development/testing blockchain.</p> <p>Inspect: * MultiversX Testnet Explorer * MultiversX Devnnet Explorer * Goerli Ethereum Testnet Explorer * Sepolia Ethereum Testnet Explorer</p> <p>What differences can you observe?</p> <p>These blockchains offer the <code>Faucet</code> option where you can mint blockchain tokens (eGLD, ETH, etc.). This way the development is easier for the community.</p> <p>NOTE</p> <p>All the tokens are \"fake\" tokens. They are only used to mock the real tokens on the Mainnet.</p>"},{"location":"chapters/introduction/lab/content/explorer/leader/","title":"Blockchain Leader","text":"<p>We will continue with the same block from the previous section (Block Height: 16826695).</p> <p></p> <p>We can observe that the Leader (also called the proposer) is <code>Istari Vision</code>. The leader, also known as the block producer or validator, is responsible for performing several critical tasks within a consensus round:</p> <ol> <li> <p>Block Proposal: The leader is tasked with proposing a new block containing a set of transactions. This block proposal is the first step in the process of reaching consensus. The leader selects transactions to include in the proposed block and creates a cryptographic hash of the block's contents.</p> </li> <li> <p>Signature and Verification: After proposing a block, the leader signs it with their private key to prove its authenticity. Other network participants can verify the leader's signature using their public key. This verification ensures that the proposed block is indeed from the authorized leader.</p> </li> <li> <p>Broadcasting the Proposal: Once the block is signed, the leader broadcasts it to the network. Other nodes in the network receive and validate the proposed block to ensure its compliance with the consensus rules.</p> </li> <li> <p>Agreement and Confirmation: If the proposed block meets the consensus criteria, it is accepted by the network. The leader's proposed block becomes part of the blockchain, and consensus is achieved for that round.</p> </li> </ol> <p>Let's see some details about this proposer:</p> <p></p> <p>We can see his public key, version of the software for the blockchain node and other information we will further discuss.</p>"},{"location":"chapters/introduction/lab/content/explorer/leader/#practice","title":"Practice","text":"<ul> <li>Open 3 different blocks in 3 different tabs. Observe that every time there is another leader. Why do you think the system is designed this way?</li> <li>Open 3 different blocks in 3 different tabs on Ethereum Explorer. Observe that every time there is another leader.</li> </ul>"},{"location":"chapters/introduction/lab/content/explorer/observers/","title":"Blockchain Observers","text":"<p>Observers are a type of nodes that <code>don't participate in the consensus</code> but keep a peer-to-peer communication with the rest of the blockchain. They are usually used to see the communication between nodes (ex: debugging). </p> <p>Let's filter the nodes to see only the observers. There is an Observers tab below the <code>Nodes</code> section.</p> <p></p> <p>We can observer the same fields as the nodes, but there is no <code>Rating</code>. Why is that?</p> <p>Note that each Observer is only on a Shard.</p> <p>What should we do if we want to listen to the communication on every shard?</p> <p>Observer that there are other types of nodes</p>"},{"location":"chapters/introduction/lab/content/explorer/time/","title":"Understanding Time in Blockchains","text":"<p>In traditional computer systems, time is relatively straightforward, with a reliance on the system clock. However, in the world of blockchains, time is a unique and critical concept. Blockchains need to maintain a shared understanding of time across all participants, and this introduces some complexities. Here's how time is managed in blockchains:</p>"},{"location":"chapters/introduction/lab/content/explorer/time/#rounds","title":"Rounds","text":"<p><code>Rounds</code> refer to the cyclic or sequential stages of consensus protocols, particularly in proof-of-stake (PoS) and delegated proof-of-stake (DPoS) blockchains. Each blockchain has it's own length of rounds: - MultiversX - 6 seconds; - Ethereum - 12 seconds; - Solana - 0.4 seconds; - Cardano - 5 seconds; - NEAR - 1 second;</p> <p>A round is a time limit to execute a batch of transactions.</p>"},{"location":"chapters/introduction/lab/content/explorer/time/#blocks","title":"Blocks","text":"<p>Every round a new block is being proposed. That proposal can succeed or not. In case of success, a block is added to the blockchain history. The missed blocks are due to not reaching consensus and are usually under 5%.</p> <p>NOTE</p> <p>For MultiversX case, every 6 seconds starts new round, but not necessarily a new block gets notarized.</p>"},{"location":"chapters/introduction/lab/content/explorer/time/#epochs","title":"Epochs","text":"<p>This is another time measurement and it's used for larger periods of time (just like minutes, hours, years, decades, etc.).</p> <p>Each blockchain has it's own length of epochs: - MultiversX - 14.400 rounds (24 hours); - Ethereum - 30.000 rounds (100 hours); - Solana - 432.000 rounds (48 hours); - Cardano - 432.000 rounds (5 days); - NEAR - 43.200 rounds (12 hours).</p>"},{"location":"chapters/introduction/lab/content/explorer/time/#block-timestamps","title":"Block Timestamps","text":"<p>Blockchains organize transactions into blocks, and each block has a timestamp. This timestamp is crucial for several reasons:</p> <ol> <li> <p>Order of Transactions: The timestamp helps order transactions within a block. Transactions are grouped together and processed in the order in which they are added to a block. This ensures that everyone has a consistent view of the transaction history.</p> </li> <li> <p>Difficulty Adjustment: Some blockchains, like Bitcoin, use the block timestamp to adjust the difficulty of the proof-of-work (PoW) algorithm. This keeps the block generation rate relatively constant, regardless of the total network hash rate.</p> </li> <li> <p>Block Validity: Block timestamps are used to determine whether a block is valid. If the timestamp of a new block is too far in the future or past, it can be considered invalid.</p> </li> </ol>"},{"location":"chapters/introduction/lab/content/explorer/time/#practice","title":"Practice","text":"<p>Check MultiversX Explorer and Ethereum Explorer and see how (almost) at every 6, respectively 12 seconds a new block appears.</p>"},{"location":"chapters/introduction/lab/content/explorer/transactions/","title":"Transactions","text":"<p>We will continue with the same block from the previous section (Block Height: 16826695).</p> <p>Observe the field Transactions:  We can see that there are 6 transactions in this group.</p>"},{"location":"chapters/introduction/lab/content/explorer/transactions/#miniblocks","title":"Miniblocks","text":"<p>Transactions are grouped in miniblocks. Each miniblock is a category with <code>Shard_source - Shard_destionation</code>.</p> <p>So, for the first miniblock we have 3 transactions from Shard1 to Shard2: </p>"},{"location":"chapters/introduction/lab/content/explorer/transactions/#transaction-details","title":"Transaction details","text":"<p>We will use the first transaction from the first miniblock as an example:</p> <p></p> <p>Observe the fields: - Status: Success; - Age: timestamp; - Miniblock: the one we previously discussed about; - From: The user who created the transaction - To: The destination of the transaction. This is a smart contract. We will discuss about it in a further section; - Value: The number of EGLD (MultiversX native token) sent in this transaction</p> <p>There are more fields in this transaction, but we will discuss about it in a further section.</p>"},{"location":"chapters/introduction/lab/content/explorer/transactions/#practice","title":"Practice","text":"<ul> <li>Open 3 different transactions in 3 different tabs. Inspect the fields.</li> <li>Open 3 different transactions in 3 different tabs on Ethereum Explorer. Inspect the fields.</li> </ul>"},{"location":"chapters/introduction/lab/content/explorer/validators/","title":"Blockchain Validators","text":"<p>Every validators/node is publicly displayed on the explorer: * MultiverX Validators; * Ethereum Nodes; * Solana Validators.</p> <p>You can check on the explorer the nodes of every blockchain.</p> <p>NOTE</p> <p>We call <code>nodes</code> or <code>validators</code> the computers who participate in the blockchain to execute transactions. The more available nodes, the more decentralized the blockchain is.</p> <p>Let's stick to the MultiversX. Go to the Nodes Section.</p> <p></p> <p>Observe the nodes public information: * Public Key * Name * Shard * Node Software Version * Status * Rating * Nonce</p> <p>We recall that the <code>Nonce</code> is the number of transaction that user transmitted on the blockchain.</p>"},{"location":"chapters/introduction/lab/content/explorer/validators/#rating","title":"Rating","text":"<p>Each individual validator has a <code>Rating</code> score, which expresses its overall reliability, performance and responsiveness. When validators join the network immediately after staking, they start with an initial score of <code>50 points</code>.</p> <p>Validators gain or lose rating points in a round depending on their role in that round (consensus proposer vs. consensus validator) and on their behavior within that role.</p> <p>For the overall health of the network, if the rating of a validator drops below 10 points, it will be <code>jailed</code>. Being jailed means that the validator will be taken out of the shards, it will not participate in consensus, and thus it will not earn any rewards.</p> <p>Rating affects the probability of a validator to be selected in the consensus group of a round. This is done by applying rating modifiers on the probability of selection for each validator.</p> <p>You can read more on rating shard validators here.</p>"},{"location":"chapters/introduction/lab/content/explorer/validators/#node-details","title":"Node details","text":"<p>The explorer offers details on each node participant to the blockchain.</p> <p></p>"},{"location":"chapters/introduction/lab/content/explorer/validators/#practice","title":"Practice","text":"<ul> <li>Open 3 different nodes on MultiversX Explorer and inspect them;</li> <li>Open 3 different nodes on Ethereum Explorer and inspect them;</li> <li>Open 3 different nodes on Solana Explorer and inspect them;</li> </ul>"},{"location":"chapters/introduction/lab/content/observer/observer/","title":"Setting up an Observer","text":"<p>In this section we will be setting up an Observer on the MultiversX Testnet.</p> <p>Clone the installer repository:</p> <pre><code>git clone https://github.com/multiversx/mx-chain-scripts\n</code></pre> <p>Edit <code>ENVIRONMENT</code> and <code>CUSTOM_HOME</code> in <code>config/variables.cfg</code> config file:</p> <pre><code>ENVIRONMENT=\"testnet\"\n\nCUSTOM_HOME=\"/home/costin\"\nCUSTOM_USER=\"costin\n</code></pre> <p>Don't forget to put your Github Token in the <code>GITHUBTOKEN</code> field. Please check that the `CUSTOM_HOME`` directory exists. </p> <p>Run the installation script as follows:</p> <pre><code>./script.sh observing_squad\n</code></pre> <p>Start the nodes and the Proxy using the command:</p> <pre><code>./script.sh start\n</code></pre> <p>If you encounter any issue please check the MultiversX Observing Squad Documentation.</p>"},{"location":"chapters/introduction/lab/content/observer/observer/#monitoring-and-trivial-checks","title":"Monitoring and trivial checks","text":"<p>One can monitor the running Observers using the termui utility (installed during the setup process itself in the CUSTOM_HOME=\"/home/ubuntu\" folder), as follows:</p> <pre><code>~/elrond-utils/termui --address localhost:8080    # Shard 0\n~/elrond-utils/termui --address localhost:8081    # Shard 1\n~/elrond-utils/termui --address localhost:8082    # Shard 2\n~/elrond-utils/termui --address localhost:8083    # Metachain\n</code></pre> <p></p>"},{"location":"chapters/introduction/lab/content/setup/setup/","title":"Setting up your environment","text":"<p>In this section we will install all the requirements needed for the practical sessions. This includes the following: - rustup - The Rust toolchain installer - MetaMask - Ethereum wallet - mxpy - tool for interacting with the blockchain - sc-meta - universal smart contract management tool</p>"},{"location":"chapters/introduction/lab/content/setup/setup/#rustup-the-rust-toolchain-installer","title":"Rustup - The Rust toolchain installer","text":"<p>Rust is installed and managed by the <code>rustup</code> tool. If you've installed <code>rustup</code> in the past, you can update your installation by running <code>rustup update</code>.</p> <p>For more informantion, please check rustup documentation.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre>"},{"location":"chapters/introduction/lab/content/setup/setup/#configuring-the-path-environment-variable","title":"Configuring the PATH environment variable","text":"<p>In the Rust development environment, all tools are installed to the <code>~/.cargo/bin</code> directory, and this is where you will find the Rust toolchain, including <code>rustc</code>, <code>cargo</code>, and <code>rustup</code>.</p> <p>During installation <code>rustup</code> will attempt to configure the <code>PATH</code>. Because of differences between platforms, command shells, and bugs in <code>rustup</code>, the modifications to <code>PATH</code> may not take effect until the console is restarted, or the user is logged out, or it may not succeed at all.</p> <p>Please make sure you have included  <code>~/.cargo/bin</code> directory in your <code>PATH</code> environment variable.</p> <p>Please verify that <code>rustup</code> was succesffully install with <code>rustup --version</code>.</p>"},{"location":"chapters/introduction/lab/content/setup/setup/#uninstall-rust","title":"Uninstall Rust","text":"<p>If at any point you would like to uninstall Rust, you can run <code>rustup self uninstall</code>.</p>"},{"location":"chapters/introduction/lab/content/setup/setup/#multiversx-prerequisites","title":"MultiversX prerequisites","text":""},{"location":"chapters/introduction/lab/content/setup/setup/#mxpy","title":"mxpy","text":"<p>Mxpy is a tool for interaction with the blockchain: <pre><code>----------------------\nCOMMAND GROUPS summary\n----------------------\ncontract                       Build, deploy, upgrade and interact with Smart Contracts\ntx                             Create and broadcast Transactions\nvalidator                      Stake, UnStake, UnBond, Unjail and other actions useful for Validators\naccount                        Get Account data (nonce, balance) from the Network\nledger                         Get Ledger App addresses and version\nwallet                         Create wallet, derive secret key from mnemonic, bech32 address helpers etc.\ndeps                           Manage dependencies or multiversx-sdk modules\nconfig                         Configure multiversx-sdk (default values etc.)\nlocalnet                       Set up, start and control localnets\ndata                           Data manipulation omnitool\nstaking-provider               Staking provider omnitool\ndns                            Operations related to the Domain Name Service\n</code></pre></p> <p>Before installing <code>mxpy</code>, please make sure you have a working <code>Python 3</code> environment. You'll need <code>Python 3.8</code> or later on Linux or MacOS.</p> <p>The recommended way to install <code>mxpy</code> is by using <code>pipx</code>. If you'd like to use <code>mxpy</code> on Windows, we recommend installing it within the Windows Subsystem for Linux (WSL).</p> <p>In order to install <code>mxpy</code> using <code>pipx</code>, run the following command: <pre><code>pipx install multiversx-sdk-cli --force\n</code></pre></p> <p>To check that mxpy installed successfully you can run the following command: <pre><code>mxpy --version\n</code></pre></p>"},{"location":"chapters/introduction/lab/content/setup/setup/#wasm32-unknown-unknown","title":"wasm32-unknown-unknown","text":"<p>This is WebAssembly target which uses 32-bit memories. It is used to compile MultiversX smart contracts to WebAssembly.</p> <p>To add it, please use: <pre><code>rustup target add wasm32-unknown-unknown\n</code></pre></p>"},{"location":"chapters/introduction/lab/content/setup/setup/#sc-meta","title":"sc-meta","text":"<p>This tool is used to compile smart contracts.</p> <p>To install it, run: <pre><code>cargo install multiversx-sc-meta --locked\n</code></pre></p> <p>To verify that it's correctly installed, run: <pre><code>sc-meta --version\n</code></pre></p>"},{"location":"chapters/introduction/lab/content/setup/setup/#ethereum-prerequisites","title":"Ethereum prerequisites","text":""},{"location":"chapters/introduction/lab/content/setup/setup/#metamask","title":"MetaMask","text":"<p>MetaMask is a web browser extension and mobile app that allows you to manage your Ethereum private keys.  By doing so, it serves as a wallet for Ether and other tokens, and allows you to interact with decentralized applications, or dapps.</p> <p>Please visit this to install MetaMask as a browser extension (Safari is not supported) or as a mobile app.</p>"},{"location":"chapters/introduction/lab/content/setup/setup/#hardhat","title":"Hardhat","text":"<p>Hardhat is a development environment for Ethereum software. It consists of different components for editing, compiling, debugging and deploying your smart contracts and dApps, all of which work together to create a complete development environment.</p> <p>To install Hardhat, use: <pre><code>npm install --save-dev hardhat\n</code></pre></p> <p>To verify that hardhat is install, run: <pre><code>$ npx hardhat\n888    888                      888 888               888\n888    888                      888 888               888\n888    888                      888 888               888\n8888888888  8888b.  888d888 .d88888 88888b.   8888b.  888888\n888    888     \"88b 888P\"  d88\" 888 888 \"88b     \"88b 888\n888    888 .d888888 888    888  888 888  888 .d888888 888\n888    888 888  888 888    Y88b 888 888  888 888  888 Y88b.\n888    888 \"Y888888 888     \"Y88888 888  888 \"Y888888  \"Y888\n\n\ud83d\udc77 Welcome to Hardhat v2.22.12 \ud83d\udc77\u200d\n\n? What do you want to do? \u2026 \n  Create a JavaScript project\n  Create a TypeScript project\n  Create a TypeScript project (with Viem)\n  Create an empty hardhat.config.js\n\u276f Quit\n</code></pre></p> <p>For the ones that prefer, there is a Hardhat for Visual Studio Code.</p>"},{"location":"chapters/introduction/lab/content/wallet/browser_wallet/","title":"Browser Wallet Extension","text":"<p>The MultiversX DeFi Wallet can be installed on Firefox, Chrome, Brave, and other chromium-based browsers. This extension is free and secure, with compelling features that allow you to create a new wallet or import existing wallets, manage multiple wallets on the MultiversX mainnet, and store MultiversX tokens such as EGLD, ESDT, or NFTs on the MultiversX Network with easy accessibility.</p> <p>Follow the tutorial here to install a Browser extension.</p>"},{"location":"chapters/introduction/lab/content/wallet/cmdline_wallet/","title":"First Blockchain transaction","text":"<p>Let's perform our first ever blockchain transaction. We will do this on MultiversX blockchain.</p> <p>First, we need a wallet. Every access, read, write, execute, etc to the blockchain needs to be sign by you with a private key (a wallet).</p> <p>To create a wallet simply run: <pre><code>$ mxpy wallet new --format pem --outfile new_wallet.pem\n</code></pre></p> <p>Let's interpret the output: <pre><code>$ mxpy wallet new --format pem --outfile new_wallet.pem\nMnemonic: bid blind field captain bar produce brush salute luggage double hole wonder meadow glass destroy giraffe auction square crush catalog knee lizard century nasty\nWallet address: erd1pfhel08mq6ucua005qgyvwq0el78ap3ytpcugy35yvqfdeq7afqsydkj3d\n</code></pre></p> <p>First, there is a mnemonic: 24 random words. These words are used to create your private key (wallet) at any time, so you must store them carefully. For now, this is only a test wallet, so just store them in a text file on your computer.</p> <p>Second, we have a wallet address. This is our blockchain address.</p> <p>Third, we have a new file <code>new_wallet.pem</code> that contains our private key (wallet): <pre><code>$ cat new_wallet.pem \n-----BEGIN PRIVATE KEY for erd1pfhel08mq6ucua005qgyvwq0el78ap3ytpcugy35yvqfdeq7afqsydkj3d-----\nNjM1N2UxOGQxYjBjMDk5ZjY1MzM2OWUxZGFiZGM3Mzg1Yjc5ZmY0ZWNlZTBiNWY5\nNWFmNjE1MzZjZDMwODNhOTBhNmY5ZmJjZmIwNmI5OGU3NWVmYTAxMDQ2MzgwZmNm\nZmM3ZTg2MjQ1ODcxYzQxMjM0MjMwMDk2ZTQxZWVhNDE=\n-----END PRIVATE KEY for erd1pfhel08mq6ucua005qgyvwq0el78ap3ytpcugy35yvqfdeq7afqsydkj3d-----\n</code></pre></p>"},{"location":"chapters/introduction/lab/content/wallet/faucet/","title":"Access a wallet","text":"<p>Go to Testnet Wallet and click on \"PEM\" (bottom of the screen); click \"Select a file\" and locate your wallet <code>new_wallet.pem</code>.</p> <p></p> <p>And you\u2019re in! Your EGLD address is on top, you can use the \u201ccopy\u201d button (the two rectangles) to copy it to the clipboard.</p>"},{"location":"chapters/introduction/lab/content/wallet/faucet/#faucet","title":"Faucet","text":"<p>You can request test tokens from the Faucet tab.</p> <p></p>"},{"location":"chapters/introduction/lab/content/wallet/faucet/#practice","title":"Practice","text":"<p>Request tokens via Faucet functionality.</p>"},{"location":"chapters/introduction/lab/content/wallet/keystore/","title":"Keystore files","text":"<p>The MultiversX keystore is a JSON file that holds a mnemonic (seed phrase), encrypted with a password (as chosen by the user). Thus, the keystore provides users with a reliable and convenient method for managing their hot wallets and protecting their assets.</p> <p>Here is an example of a MultiversX Keystore:</p> <pre><code>{\n    \"version\": 4,\n    \"id\": \"5b448dbc-5c72-4d83-8038-938b1f8dff19\",\n    \"kind\": \"mnemonic\",\n    \"crypto\": {\n        \"ciphertext\": \"6d70fbdceba874f56f15af4b1d060223799288cfc5d276d9ebb91732f5a38c3c59f83896fa7e7eb6a04c05475a6fe4d154de9b9441864c507abd0eb6987dac521b64c0c82783a3cd1e09270cd6cb5ae493f9af694b891253ac1f1ffded68b5ef39c972307e3c33a8354337540908acc795d4df72298dda1ca28ac920983e6a39a01e2bc988bd0b21f864c6de8b5356d11e4b77bc6f75ef\",\n        \"cipherparams\": {\n            \"iv\": \"2da5620906634972d9a623bc249d63d4\"\n        },\n        \"cipher\": \"aes-128-ctr\",\n        \"kdf\": \"scrypt\",\n        \"kdfparams\": {\n            \"dklen\": 32,\n            \"salt\": \"aa9e0ba6b188703071a582c10e5331f2756279feb0e2768f1ba0fd38ec77f035\",\n            \"n\": 4096,\n            \"r\": 8,\n            \"p\": 1\n        },\n        \"mac\": \"5bc1b20b6d903b8ef3273eedf028112d65eaf85a5ef4215917c1209ec2df715a\"\n    }\n}\n</code></pre> <p>At first, you will see an unappealing JSON file, which appears to contain magic parameters used for numerous complex cryptographic operations with unclear and vague purpose. But if you dig a little deeper you will see that it contains:</p> <ul> <li>kind - Can be secretKey or mnemonic and represents the input to be encrypted using the cipher;</li> <li>ciphertext - Your MultiversX mnemonic or secret key encrypted using the cipher algorithm below;</li> <li>cipher - The name of a symmetric AES algorithm;</li> <li>cipherparams - The parameters required for the cipher algorithm above;</li> <li>kdf - A key derivation function used to let you encrypt your keystore file with a password;</li> <li>kdfparams - The parameters required for the kdf algorithm above;</li> <li>mac - A code used to verify your password.</li> </ul> <p>Keystore files created with the first major version of the web wallet (available prior February 14th, 2023) hold the encrypted secret key, instead of the encrypted mnemonic (as the new keystore files do). Though the older files are still compatible with the new web wallet - compatibility is achieved through the aforementioned \"kind\" field.</p> <p>When kind is set (or not set at all) to secretKey, the ciphertext field will contain the encrypted secret key, as it did before. However, when kind is set to mnemonic, the ciphertext field will contain the encrypted mnemonic instead.</p> <p>Auxiliary reference: ERC-2335: BLS12-381 Keystore.</p>"},{"location":"chapters/introduction/lab/content/wallet/observer/","title":"Observe transaction via Observers","text":"<p>Deploy an observing squad perform a transaction and check that transaction locally on your computer.</p>"},{"location":"chapters/introduction/lab/content/wallet/send_tx/","title":"Send a transaction","text":"<p>Click \"Send\" on the right-hand section of the wallet:</p> <p></p> <p>Input the destination address &amp; amount, and then click \"Send\".</p> <p></p> <p>After confirming the transaction you can see the progress and completion of the transaction.</p>"},{"location":"chapters/introduction/lab/content/wallet/send_tx/#practice","title":"Practice","text":"<p>Check transaction history in the \"Transactions\" menu on the left-hand side of the wallet.</p> <p></p> <p>Click on the last transaction (Send Transaction) and check the details.</p> <p>Open that transaction in the Explorer. At the right hand side of the Hash field, click on the magnifier.</p> <p></p>"},{"location":"chapters/introduction/lab/content/wallet/wallet/","title":"Setting up a Wallet via Browser","text":"<p>We will use MultiversX Testnet Wallet to participate in the blockchain as a user.</p> <p>If you already have a wallet, there is no need to create another one.</p> <p>Go to MultiversX Testnet Wallet and create a new wallet by clicking Create new one.</p> <p></p> <p>Carefully read and acknowledge the information, then click \"Continue\".</p> <p></p>"},{"location":"chapters/introduction/lab/content/wallet/wallet/#save-your-secret-phrase-this-is-very-important","title":"Save your secret phrase! This is very important","text":"<p>Each wallet will have 24 secret words that can be used for recovery. </p> <p>The words, numbered in order, are your Secret Phrase. They are just displayed on your screen once and not saved on a server or anywhere in the world. You only get one chance to save them - please do so now.</p> <p>Click the \u201ccopy\u201d (two rectangles) button and then paste them into a text file. If your pets don\u2019t usually find important pieces of paper to be delicious, you could even write the words down.</p> <p></p> <p>The next page is a test to see if you actually have saved the Secret Phrase. Enter the random words as indicated there and press \"Continue\".</p> <p>You are one step away from getting your Keystore File. First, encrypt it with a password. </p> <p></p> <p>In case you forget this password, you can get a new Keystore File with your secret phrase. Remembering it is always better.</p> <p>Congratulations, you have a new wallet! The associated Keystore File was downloaded to wherever your browser saves files by default. The file has the actual address of the wallet as default name, something like \u201cerd\u2026.json\u201d. You can rename it to \u201csomething.json\u201d so it\u2019s easier to manage, if you want.)</p>"},{"location":"chapters/introduction/lecture/slides/","title":"Introduction to Blockchains","text":"<ol> <li>Introduction</li> </ol>"},{"location":"chapters/introduction/lecture/slides/#software-stack","title":"Software Stack","text":""},{"location":"chapters/introduction/lecture/slides/#flexibility-of-software","title":"Flexibility of Software","text":"<ul> <li>Hardware provides basic actions</li> </ul> <ul> <li>Users request rich features</li> </ul> <ul> <li>Software bridges the gap between user demands and hardware possibility</li> </ul>"},{"location":"chapters/introduction/lecture/slides/#hardware-vs-software","title":"Hardware vs Software","text":"Hardware Software do one thing, do one thing well flexible efficient featureful unmodifiable (un)installable, configurable physical virtual, easy to duplicate use once at a time reusable monolithic (de/re)composable"},{"location":"chapters/introduction/lecture/slides/intro/","title":"Home","text":""},{"location":"chapters/introduction/lecture/slides/intro/#software-stack","title":"Software Stack","text":""},{"location":"chapters/introduction/lecture/slides/intro/#flexibility-of-software","title":"Flexibility of Software","text":"<ul> <li>Hardware provides basic actions</li> </ul> <ul> <li>Users request rich features</li> </ul> <ul> <li>Software bridges the gap between user demands and hardware possibility</li> </ul>"},{"location":"chapters/introduction/lecture/slides/intro/#hardware-vs-software","title":"Hardware vs Software","text":"Hardware Software do one thing, do one thing well flexible efficient featureful unmodifiable (un)installable, configurable physical virtual, easy to duplicate use once at a time reusable monolithic (de/re)composable"},{"location":"chapters/money/lab/content/lend_borrow/","title":"Lend tokens on Hatom","text":"<p>In this section, you will learn how to lend a token on MultiversX. For this, we will use the Devnet Hatom, a MultiversX Decentralized Lending Protocol.</p>"},{"location":"chapters/money/lab/content/mint_tokens/","title":"Mint tokens","text":"<p>In this section you will learn how to mint tokens on MultiversX.</p> <p>There are 2 types of tokens on MultiversX: * Native tokens - EGLD; * ESDT - eStandard Digital Token.</p> <p>In the previous section you learnt how to mint xEGLD on MultiversX Testnet using <code>Faucet</code> option.</p> <p></p>"},{"location":"chapters/money/lab/content/mint_tokens/#mint-esdt","title":"Mint ESDT","text":"<p>This time we use the <code>Create Token</code> option.</p> <p>Token Name: * length between 3 and 20 characters * alphanumeric characters only</p> <p>Token Ticker: * length between 3 and 10 characters * alphanumeric UPPERCASE only</p> <p>Number of decimals: * should be a numerical value between 0 and 18; * there are no floats on the blockchain; * a token with 3 decimals and value 1000 would be equal with value 1; * EGLD has 18 decimals and the value of 1000000000000000000 is 1 EGLD.</p> <p>Let's create a token new token:</p> <p></p> <p>and inspect the transaction.</p> <p></p> <p>Observe <code>Token Operations</code> field. We received <code>321.00 BPDA-208994</code> tokens. <code>BPDA-208994</code> is the token ID. The token ID is formed by appending to the token ticker the character - and 6 random hexadecimals characters. This is done because there might be multiple tokens with the same ticker; the token ID is always unique.</p> <p>We can click on the token ID and see the details of the token:</p> <p></p> <p>Observe the fields TOKEN, Supply, Holders, Transactions, Owner, Decimals.</p> <p>Let create another token with the same input:</p> <p></p> <p>Observe that the token ID is different.</p>"},{"location":"chapters/money/lab/content/mint_tokens/#practice","title":"Practice","text":"<ul> <li>Create your own ESDT token;</li> <li>Inspect the transaction;</li> <li>Send some of your tokens to erd1mqa9wttlzwwdvwgk9dzsfdn79lv5raw0tfe9ynvn0dg92hpruvaqhhd2gx;</li> <li>Create another token with the same ticker. Observer that the token ID is different and unique.</li> </ul>"},{"location":"chapters/money/lab/content/swap/","title":"Swap tokens on xExchange","text":"<p>In this section, you will learn how to swap a token with another on MultiversX. For this, we will use the Devnet xExchange, a MultiversX Decentralized Exchange.</p> <p>Keep in mind that Devnet and Testnet chains are different! First go to Devnet Wallet and use Faucet functionality to get xEGLD. </p> <p></p> <p>Use Connect button and connect with your wallet via your preferred method.</p> <p>Let's perform a swap from EGLD to ASH.</p> <p> Notice that for 1 EGLD, we would get 212 ASH tokens.</p> <p>Let's try to swap more: </p> <p>Notice that for 10 EGLD, we would get 1498 ASH tokens. That's 149.8 ASH tokens for 1 EGLD.</p> <p>Any intuition of why the drop of exchange rate?</p> <p>Let's try to swap more: </p> <p>Notice that for 100 EGLD, we would get 3798 ASH tokens. That's 37.98 ASH tokens for 1 EGLD.</p>"},{"location":"chapters/money/lab/content/swap/#automated-market-maker-amm","title":"Automated Market Maker (AMM)","text":"<p>An AMM relies on a mathematical formula to price assets. Instead of using an order book like a traditional exchange, assets are priced according to a pricing algorithm.</p> <p>This formula can vary with each protocol. For example, xExchange DEX uses the industry standard \"x*y=k\" constant product AMM model, which has proven its reliability in existing implementations, and has been formally modelled and verified. In this formula, k is a fixed constant, meaning the pool\u2019s total liquidity always has to remain the same.</p> <p></p>"},{"location":"chapters/money/lab/content/swap/#pair-smart-contract","title":"Pair Smart Contract","text":"<p>The smart contract code can be found here.</p> <p>Let's inspect the deployed contract.</p> <p></p> <p>Notice the contract's balance: * WEGLD: 27.14 * ASH: 4,817.99 * ASHWEGLD: 0.000000000000001 - This is the token provided to liquidity providers when they add liquidity. Let's ignore this for now.</p> <p>Let's try to exchange more ASH than the contract can provide:</p> <p></p> <p>In this example, we tried to exchange 100 millions EGLD, but the contract would output 4,580.0391 ASH tokens. That's because of the curve of x*y=k formula (see image above).</p>"},{"location":"chapters/money/lab/content/swap/#task","title":"Task","text":"<p>Perform a swap. Go to the Explorer and inspect your transaction. Inspect if there are any evets emitted.</p>"},{"location":"chapters/money/lecture/slides/intro/","title":"Slides","text":""},{"location":"chapters/money/lecture/slides/intro/#flexibility-of-software","title":"Flexibility of Software","text":"<ul> <li>Hardware provides basic actions</li> </ul> <ul> <li>Users request rich features</li> </ul> <ul> <li>Software bridges the gap between user demands and hardware possibility</li> </ul>"},{"location":"chapters/peer-to-peer/lab/content/basic_wallet/","title":"Basic Wallet","text":"<p>To create a public key with which we can display our financial gain in the internet we need first to generate a private key using an algorithm, the private key will generate the public key and\u2026from now on we can apply a hash on it and remove some character from behind and add 0x in front to know that this is a public address.</p> <p> </p> <pre><code>/function to create a public and private key\nfunc CreateKeyPair() (crypto.PrivKey, crypto.PubKey, error) {\n //   Create a private and public key pair\n priv, pub, err := crypto.GenerateKeyPair(crypto.RSA, 2048)\n if err != nil {\n  return nil, nil, err\n }\n\n return priv, pub, nil\n}\n\nfunc CreatePairPublicPrivateKey() ([]byte, []byte) {\n\n //create a private and public key\n priv, pub, err := CreateKeyPair()\n if err != nil {\n  panic(err)\n }\n\n //convert private key to bytes\n privBytes, err := crypto.MarshalPrivateKey(priv)\n if err != nil {\n  panic(err)\n }\n\n //convert public key to bytes\n pubBytes, err := crypto.MarshalPublicKey(pub)\n if err != nil {\n  panic(err)\n }\n\n //list of bytes to string\n privString := hex.EncodeToString(privBytes)\n pubString := hex.EncodeToString(pubBytes)\n\n //create a wallet variable\n wallet := types.Wallet{\n  PrivateKey: []byte(privString),\n  PublicKey:  []byte(pubString),\n }\n //convert wallet to bytes marshal\n walletBytes, _ := json.Marshal(wallet)\n\n //put wallet in the db\n fileop.PutInDB(\"db/usr\", []byte(\"wallet1\"), walletBytes)\n\n return []byte(pubString), []byte(privString)\n\n} \n</code></pre> <p>For generating privateKey and publicKey we will use RSA because is very common and is easy to understand then we store the data into a wallet struct and the struct will be stored on our local storage.</p> <p>So well we will mine a block we will get the first transaction from coinbase</p> <pre><code>{\"BlockNumber\":0,\n\"Time\":1668970059,\n\"Hash\":\"06c6836e73c1676d58f938fd17a91224b50e5de97623dcc80c4f48d6eb96e052\",\n\"Inputs\":[{\"Txid\":0,\"Value\":1,\"Signature\":\"\",\"PubKey\":\"coinbase\"}],\n\"Outputs\":[{\"Txid\":0,\"Value\":1,\"PubKeyHash\":\"0x2432\\n\",\"Signature\":\"\"}]\n}\n</code></pre> <p>Every input and output transactions will be signed, so this will be saw by everyone from the blockchain, we will cache this on our wallet because we will be easy when we want to create a transaction.</p> <p>In bitcoin there isn\u2019t the idea of a balance like having 200 bitcoin, when you send a transaction you also send how you get that money.(we can see how the money where spent.</p> <p></p> <p>Our wallet when is creating transaction 3 will say the input from transaction1 and transaction2 and the the outputs like in the json above.</p> <p>Here is an example of a real bitcoin transaction. Also you signed with your private key what you send to the other peers.</p> <pre><code>{\n    \"txid\": \"1b3cb78e7d6cad2cc2050e6dccc2bd5845e98f598062d19fbda8e0a3b5b4b0e6\",\n    \"hash\": \"9d046215268a1d8031c6b4835a68c9c8c6984b576dc82ec37f859e636ec6e660\",\n    \"version\": 1,\n    \"size\": 368,\n    \"vsize\": 341,\n    \"weight\": 1364,\n    \"locktime\": 1064830807,\n    \"vin\": [\n        {\n            \"coinbase\": \"039ea80b2cfabe6d6df2adbfb95872a2c4bf41bd0af61255f06bc31f0aa11d1c2b11fe673f0a94af3e10000000f09f909f092f4632506f6f6c2f73000000000000000000000000000000000000000000000000000000000000000000000005001d000000\",\n            \"txinwitness\": [\n                \"0000000000000000000000000000000000000000000000000000000000000000\"\n            ],\n            \"sequence\": 0\n        }\n    ],\n    \"vout\": [\n        {\n            \"value\": 6.28864092,\n            \"n\": 0,\n            \"scriptPubKey\": {\n                \"asm\": \"OP_DUP OP_HASH160 c825a1ecf2a6830c4401620c3a16f1995057c2ab OP_EQUALVERIFY OP_CHECKSIG\",\n                \"hex\": \"76a914c825a1ecf2a6830c4401620c3a16f1995057c2ab88ac\",\n                \"address\": \"1KFHE7w8BhaENAswwryaoccDb6qcT6DbYY\",\n                \"type\": \"pubkeyhash\"\n            }\n        },\n        {\n            \"value\": 0,\n            \"n\": 1,\n            \"scriptPubKey\": {\n                \"asm\": \"OP_RETURN aa21a9ed7c2862196195aa9d4d8b947653d3548ffe4c111d5669a6ec2c96f12f91672884\",\n                \"hex\": \"6a24aa21a9ed7c2862196195aa9d4d8b947653d3548ffe4c111d5669a6ec2c96f12f91672884\",\n                \"type\": \"nulldata\"\n            }\n        },\n        {\n            \"value\": 0,\n            \"n\": 2,\n            \"scriptPubKey\": {\n                \"asm\": \"OP_RETURN 48617468cd302e8d060f04304c01afa1fd1a73a8538f6eee545aa1c0a97e54fa4db86856\",\n                \"hex\": \"6a2448617468cd302e8d060f04304c01afa1fd1a73a8538f6eee545aa1c0a97e54fa4db86856\",\n                \"type\": \"nulldata\"\n            }\n        },\n        {\n            \"value\": 0,\n            \"n\": 3,\n            \"scriptPubKey\": {\n                \"asm\": \"OP_RETURN 52534b424c4f434b3a8350e01a86adc281c624fc5e9e1ba740ac5c1a38c0413a51b5ab342800498b80\",\n                \"hex\": \"6a4c2952534b424c4f434b3a8350e01a86adc281c624fc5e9e1ba740ac5c1a38c0413a51b5ab342800498b80\",\n                \"type\": \"nulldata\"\n            }\n        }\n    ]\n}  \n</code></pre> <p>This is our code for the signing of the transactions.</p> <pre><code>func SingUsingKey(privateKey []byte, publicKey []byte, data []byte) []byte {\n if GetPrivateKeyAndValidatePublicKey(publicKey) {\n  //decode private key\n  privKeyBytes, _ := hex.DecodeString(string(privateKey))\n  //unmarshal private key\n  privKey, err := crypto.UnmarshalPrivateKey(privKeyBytes)\n  if err != nil {\n   log.Printf(\"Error unmarshalling private key: %s\", err)\n   return nil\n  }\n\n  //sign data\n  signature, err := privKey.Sign(data)\n  if err != nil {\n   log.Printf(\"Error signing data: %s\", err)\n   return nil\n  }\n\n  return signature\n\n } else {\n  fmt.Println(\"Public key does not match private key\")\n  return nil\n }\n\n}\n\nfunc VerifySign(signature []byte, publicKey []byte, data []byte) bool {\n\n pubKey, err := crypto.UnmarshalPublicKey(publicKey)\n if err != nil {\n  log.Printf(\"Error unmarshalling public key: %s\", err)\n  return false\n }\n\n //verify signature\n verify, err := pubKey.Verify(data, signature)\n if err != nil {\n  return false\n }\n\n return verify\n}\n</code></pre>"},{"location":"chapters/peer-to-peer/lab/content/discovery_node/","title":"What is a discovery node?","text":"<p>In the context of Libp2p in Golang, a \"discovery node\" typically refers to a node that participates in a discovery process to find and connect to other peers in the network. Discovery is an essential aspect of decentralized systems, as it allows nodes to discover and establish connections with their peers dynamically.</p> <p>Libp2p provides a set of discovery mechanisms, and a discovery node is a peer that actively participates in these mechanisms. These mechanisms help nodes find each other by disseminating information about the network's topology.</p> <p>Here are some common discovery mechanisms in Libp2p:</p> <p>MDNS (Multicast DNS): This is a protocol that allows nodes on a local network to discover each other without relying on a centralized server. Nodes announce their presence on the network, and others can listen for these announcements. </p> <p>Bootstrap Nodes: These are well-known nodes that act as initial points of contact for new nodes entering the network. New nodes can connect to these bootstrap nodes to discover other peers in the network. </p> <p>DHT (Distributed Hash Table): Libp2p uses a DHT to store and retrieve information about peers in a decentralized manner. Nodes in the network can query the DHT to discover the addresses of other peers. </p> <p>The role of a discovery node is to participate in one or more of these mechanisms, helping peers find each other and establish connections in a decentralized way. This is crucial for the robustness and scalability of decentralized systems, as it enables nodes to adapt to changes in the network's topology dynamically.</p>"},{"location":"chapters/peer-to-peer/lab/content/mining/","title":"Mining a block","text":"<p>In this tutorial we will use the most simple and basic way to mine a block.We will use proof of work.</p> <p><pre><code>sha256(\"0xs2rgi3p4jfbt43hrjweafwefwff\"+0)=\"t09q3pfoewjaiougt80u9ropijdd\"\nsha256(\"0dnoirihp32u823u42o324rwfadsq\"+1)=\"981r03q2ipfout8403qrp2ojiht\"\nsha256(\"8q349pjrofioh83409prjfdsfaeoi\"+2)=\"802394qrpjiu58u93q4ropjohir\"\nsha256(\"9q0fwei0923rupi0u439rp034u9rr\"+3)=\"fo9432ropeif43092oekr3op32r\"\nsha256(\"9r01fhewogr9u3jfeopijot0q49ru\"+4)=\"f43epkfoij5t43pwelmfijwerk3\"\nsha256(\"t4280fhpibtqgh0w9pitq4ghgpit4\"+5)=\"p9340ropjiot80932orit43jt09\"\n----------------------------------------------------------------------\n//after a lot of iteration we will get to a hash that looks like this\n----------------------------------------------------------------------\nsha256(\"t4280fhpibtqgh0w9pitq4ghgpit4\"+123)=\"000p9340ropjiot80932orit43jt09\"\n//we have some zeros in the front(we chose the number of zeros \n//so this hash is valid\n</code></pre> </p> <p>Proof of work is a computational method employed to arrive at a valid solution by repeatedly hashing data until a hash with a specific number of leading zeros is obtained. Achieving multiple leading zeros in a hash is a challenging and low-probability task.</p> <p></p> <p>The idea that is present in the code above can expand more, what if we link the transactions with the block? \u2014 we concatenate all the content together and apply a hash function on all of them so we will get to a specific number of zeros and that block becomes valid.</p> <p>In the bottom image we see what is our end goal\u2026so the blocks need to be linked together ( to create a blockchain ). From the bottom image we see that the blocks are linked by the prev hash. And all the transaction are put in a Merkle tree then the root node is added to blockchain.</p> <p></p> <p>This is the structure of a block.</p> <pre><code>//block struct\ntype Block struct {\n//is the index of the block ex:0 ,1,2,3\n Index      int      `json:\"index\"`\n//time of the block when is mined\n Timestamp  int64    `json:\"timestamp\"`\n//list of transaction, we will get here later\n Tx         [][]byte `json:\"tx\"`\n//merkle root a byte of the merkle transaction tree\n MerkleRoot []byte   `json:merkle`\n//hash of the prevblock\n PrevHash   string   `json:\"prevHash\"`\n//current hash of this block\n Hash       string   `json:\"hash\"`\n//nonce the number that we try to guess when we mine a block\n Nonce      int      `json:\"nonce\"`\n//this is the reward per block\n Reward     int      `json:\"reward\"`\n//this is the current coinbase of the network we grow as the network grows\n Coinbase   int      `json:\"coinbase\"`\n//the miner how mined the block\n Miner      string   `json:\"miner\"`\n}\n</code></pre> <pre><code>func ProofOfWork(address string) types.Block {\n    getLastBlockKey := fileop.GetLastKey(\"db/blocks/blockchain\")\n    if len(getLastBlockKey) == 0 {\n        if getLastBlockKey == nil {\n            //fmt.Println(\"Genesis:\", string(getLastBlockKey))\n            //create genesis block\n            return CreateGenesisBlock(address)\n        }\n    }\n    newBlock := CreateBlock()\n    //get private and public key\n    _, privateKey := cryptogeneration.GetPublicPrivateKeys()\n    //create list of transaction\n    var tx []merkletree.Content\n    //get all transaction in levelDB\n    transaction := fileop.GetAllKeys(\"db/mempool/valid\")\n    if len(transaction) != 0 {\n        //unmarshall transaction\n        for _, v := range transaction {\n            data := fileop.GetFromDB(\"db/mempool/valid\", v)\n            transactionDB := types.Transaction{}\n            json.Unmarshal(data, &amp;transactionDB)\n            transactionDB.BlockNumber = newBlock.Index\n            //add to list of transaction\n            tx = append(tx, transactionDB)\n        }\n    }\n\n    tx = append(tx, CreateTransaction(privateKey, address, nil, 100, 0, 0))\n\n    //create merkle tree\n    merkleTree, _ := merkle.BuildTree(tx)\n    listOfTransaction, RootNode := merkle.ExportLeafs(merkleTree)\n\n    newBlock.Tx = listOfTransaction\n    newBlock.MerkleRoot = RootNode\n    //reconstruct merkle tree from string\n    //merkleTree, _ := merkle.ReconstructTree(newBlock.Tx)\n    //get merkle tree from string\n\n    iterator := 0\n    for {\n        newBlock.Nonce = iterator\n        storeHash := CalculateHash(newBlock)\n        if storeHash[:2] == \"00\" {\n            //fmt.Println(\"Hash:\", storeHash)\n            newBlock.Hash = storeHash\n            //clear db//mempool/valid\n            fileop.EraseAllKeys(\"db/mempool/valid\")\n            //fmt.Println(\"proof_of_work_func:\", newBlock)\n            return newBlock\n            break\n        }\n        iterator += 1\n    }\n\n    return types.Block{}\n}\n</code></pre> <p>Well now we have this block mined so how we will send to other peers(because a blockchain is decentralized( not always)) ?</p> <p>Up we speak about the channel that we will open to listen to data transferred in the network so\u2026 we will have a function that will send that to all the peers that we have stored in our local database.</p> <pre><code>func SendToAllPeers(node host.Host, data []byte, type_to_send int) {\n //read from db all keys\n number := fileop.GetNumberOfKeys(\"db/peers\")\n if number == 0 {\n  fmt.Println()\n } else {\n\n  //get all keys from db/peers \n  //here we read all the data from the peers table and \n  //we send the block to every one of this peer\n  keys := fileop.GetAllKeys(\"db/peers\")\n  fmt.Println(\"=================\")\n  //for each key send message\n  for i := 0; i &lt; len(keys); i++ {\n   fmt.Println(string(keys[i]))\n  }\n  fmt.Println(\"================\")\n  //for each key convert to string\n  for i := 0; i &lt; number; i++ {\n   peer_addres := string(keys[i])\n   //remove \\n from string\n   //we need \\n to read the characters to know where the row of data will end\n   peer_addres = peer_addres[:len(peer_addres)-1]\n   fmt.Println(\"Sending to peer: \", peer_addres)\n   if type_to_send == 0 {\n    //send to blocks channel\n    OpenConnectionMine(peer_addres, node, data)\n   } else if type_to_send == 1 {\n    //send to transaction channel\n    OpenConnectionTransaction(peer_addres, node, data)\n   }\n  }\n }\n}\n</code></pre> <p>Here is the the openConnectionMine function:</p> <pre><code>func OpenConnectionMine(peer_addres string, node host.Host, data []byte) {\n//here we will get the address\n addr, err := multiaddr.NewMultiaddr(peer_addres)\n if err != nil {\n  println(\"Error: address format wrong1\")\n  return\n }\n peer, err := peerstore.AddrInfoFromP2pAddr(addr)\n if err != nil {\n  println(\"Error: address format wrong2\")\n  return\n }\n\n if err := node.Connect(context.Background(), *peer); err != nil {\n  println(\"Error: connection failed\")\n  return\n }\n //we send  a block in this section that was mined \n //we open a stream to that peer\n stream, err := node.NewStream(context.Background(), peer.ID, \"/mine/1.0.0\")\n if err != nil {\n  //print err\n  log.Fatal(err)\n  println(\"Error: stream creation failed\")\n  return\n }\n fmt.Print(\"Sending message...\")\n\n //send string to stream\n _, err = stream.Write(data)\n\n if err != nil {\n  println(\"Error: message sending failed\")\n  return\n }\n}\n</code></pre>"},{"location":"chapters/peer-to-peer/lab/content/p2p_network/","title":"Peer to peer network","text":"<p>For this part we will use libp2p was used by the guys that build IPFS and Filecoin.</p> <p>First we need to spawn a p2p node</p> <pre><code>func RunSourceNode() {\n // start a libp2p node that listens on a random local TCP port,\n // but without running the built-in ping protocol\n node := CreateNode(\"/ip4/127.0.0.1/tcp/0\")\n\n // configure our own ping protocol\n pingService := &amp;ping.PingService{Host: node}\n node.SetStreamHandler(ping.ID, pingService.PingHandler)\n\n // print the node's PeerInfo in multiaddr format\n peerInfo := peerstore.AddrInfo{\n  ID:    node.ID(),\n  Addrs: node.Addrs(),\n }\n addrs, err := peerstore.AddrInfoToP2pAddrs(&amp;peerInfo)\n if err != nil {\n  panic(err)\n }\n fmt.Println(\"libp2p node address:\", addrs[0])\n//we need parallel interaction for this \n go LogicNodeInteraction(node)\n\n for {\n//here will be our local terminal to interact with the blockchain\n  terminalview.TerminalView(node)\n }\n\n}\n</code></pre> <p>Here we spawn a basic peer to peer Node now we need a way to interact with the node and some logic to be able to communicate with the other blockchains.</p>"},{"location":"chapters/peer-to-peer/lab/content/p2p_network/#synchronise-peers-inside-the-network","title":"Synchronise peers inside the network","text":"<p>So we have LogicNodeInteraction which will run in parallel with the terminal.</p> <pre><code>func LogicNodeInteraction(node host.Host) {\n //Set stream handler for the \"/hello/1.0.0\" protocol\n go node.SetStreamHandler(\"/transaction/1.0.0\", func(s network.Stream) {\n  log.Printf(\"/transaction/1.0.0 stream created\")\n  err := ReadTransactionProtocol(s)\n  if err != nil {\n   s.Reset()\n  } else {\n   s.Close()\n  }\n })\n\n go node.SetStreamHandler(\"/mine/1.0.0\", func(s network.Stream) {\n  log.Printf(\"/mine/1.0.0 stream created\")\n  err := ReadMineProtocol(s)\n  if err != nil {\n   log.Printf(\"Error: %s\", err)\n   s.Reset()\n  } else {\n   log.Printf(\"Closing stream\")\n   s.Close()\n  }\n })\n\n go node.SetStreamHandler(\"/messages/1.0.0\", func(s network.Stream) {\n  log.Printf(\"/messages/1.0.0 stream created\")\n  err := ReadMessagesProtocol(s)\n  if err != nil {\n   log.Printf(\"Error: %s\", err)\n   s.Reset()\n  } else {\n   log.Printf(\"Closing stream\")\n   s.Close()\n  }\n })\n\n}\n</code></pre> <p>Here we spawn 3 channels to listen for other peers(they need to send messages on one of this channels)</p>"},{"location":"chapters/peer-to-peer/lab/content/p2p_network/#so-what-are-they-doing","title":"So what are they doing?","text":"<p>This will be out channel of communication between our nodes. ``` \"/transaction/1.0.0\" - is responsible for transaction, here is the way our transaction will be send</p> <p>\u201d/mine/1.0.0\" \u2014 is responsible for the blocks that are mined, they will come from other nodes to this one ( here will come blocks that are valid and invalid form the other peers)</p> <p>\u201d/messages/1.0.0\" \u2014 here will come different messages about the network(transaction that are not valid\u2026etc) (we will not enter into this)```</p>"},{"location":"chapters/peer-to-peer/lab/content/sources/","title":"Sources","text":"<p>Github: https://github.com/bogdan124/master-blockchain-v.0.0.1-      </p> <p>Sources:        https://github.com/kyuupichan/bitcoin-0.01      https://bitcoin.org/bitcoin.pdf       https://learnmeabitcoin.com/     </p>"},{"location":"chapters/peer-to-peer/lab/content/terminal/","title":"The terminal","text":"<p>This terminal will be a way to interact with other nodes.l(\u201ccomplete code will be available on github\u201d)</p> <p><pre><code>func TerminalView(node host.Host) {\n //print a menu with 8 options\n //1. Create a new wallet\n //2. View your wallet\n //3. Send coins\n //4. View your transactions\n //5. Mine\n //6. Options\n //7. Exit\n\n theEntireMenu()\n\n //read data from keyboard\n reader := bufio.NewReader(os.Stdin)\n fmt.Print(\"&gt;\")\n text, _ := reader.ReadString('\\n')\n fmt.Println(text)\n //remove \\n from text\n text = text[:len(text)-1]\n //verify the input\n switch text {\n case \"1\":\n  createWallet()\n case \"2\":\n  viewWallet()\n case \"3\":\n  sendCoins(node)\n case \"4\":\n  viewTransactions()\n case \"5\":\n  mine(node)\n case \"6\":\n  options()\n case \"7\":\n  exit()\n case \"8\":\n  addPeers(node)\n }\n\n}\n\nfunc theEntireMenu() {\n fmt.Println(\"+--------------------+\")\n fmt.Println(\"|1.)Create new wallet|\")\n fmt.Println(\"+--------------------+\")\n fmt.Println(\"|2.)View your wallet |\")\n fmt.Println(\"+--------------------+\")\n fmt.Println(\"|3).Send coins       |\")\n fmt.Println(\"+--------------------+\")\n fmt.Println(\"|4.)View transactions|\")\n fmt.Println(\"+--------------------+\")\n fmt.Println(\"|5.)Mine             |\")\n fmt.Println(\"+--------------------+\")\n fmt.Println(\"|6.)Options          |\")\n fmt.Println(\"+--------------------+\")\n fmt.Println(\"|7.)Exit             |\")\n fmt.Println(\"+--------------------+\")\n fmt.Println(\"|8.)Add peers        |\")\n fmt.Println(\"+--------------------+\")\n}\n</code></pre> How will look:</p> <p></p> <p>At the top of the terminal, you'll find our P2P address. This address makes it easy to share with other nodes for sending requests.</p>"},{"location":"chapters/peer-to-peer/lab/content/transactions/","title":"Transactions","text":"<p>So we have a wallet we know how a transaction looks lets send a transaction to another address in the blockchain.</p> <p>First we need to know the address where we want to send the coins.</p> <p>This is the format of a transaction.</p> <pre><code>//transaction struct\ntype Transaction struct {\n BlockNumber int\n Time        int64\n Hash        string\n Inputs      []TxInput\n Outputs     []TxOutput\n}\n\ntype TxInput struct {\n Txid      int64\n Value     int64\n Signature string\n PubKey    string\n}\n\ntype TxOutput struct {\n Txid       int64\n Value      int64\n PubKeyHash string\n Signature  string\n}\n</code></pre> <p>After we send the transaction from our node, the data will be sent across the network to all the nodes, now the nodes will start to validate the transaction(what means to validate the transaction? \u2014 first to check that input money are valid by verify the signature of the one that send money to the person that is sending towards you.</p> <p>If a transaction is invalid the node will not send the transaction further in the network and will send a message to the node that send the invalid transaction that the transaction is invalid.</p> <p>But if the transaction is valid will be send further to the other nodes and stored in a mempool until\u2026a node will chose to mine a block and to add the transaction into the blockchain.</p>"},{"location":"chapters/peer-to-peer/lab/content/what_we_build/","title":"What we will build?","text":"<ul> <li>Peer to peer network</li> <li>Synchronise peers inside the network</li> <li>Mine a block and send it to the other peers</li> <li>Have a basic wallet and add money to it when we mine a block</li> <li>Send transactions and approve them into blockchain</li> </ul> <p>You can git clone the repo from here.</p>"},{"location":"chapters/peer-to-peer/lab/content/why_golang/","title":"Why golang?","text":"<p>Golang is an excellent choice for building a blockchain due to its readability and widespread use in the field. Its popularity stems from the simplicity of its syntax and the prevalence of libraries commonly employed in blockchain development.</p> <p>One of Golang's standout features is its speed, a crucial factor when dealing with the intricate operations of a blockchain. This language's efficiency ensures that the blockchain can handle tasks swiftly and responsively.</p> <p>Moreover, Golang provides the libp2p library, a valuable tool for simplifying the creation of a peer-to-peer network. This library streamlines the process of connecting nodes in a decentralized system, making it easier for developers to establish and maintain a robust network.</p> <p>Golang's support for parallelism is another asset. Using the 'go' keyword before a function enables easy implementation of parallel and asynchronous operations. This feature enhances the performance of the blockchain by allowing it to execute multiple tasks simultaneously, contributing to a more efficient and responsive system.</p> <ul> <li>You can go and install golang from here</li> <li>You can install libp2p from here</li> </ul>"},{"location":"chapters/protocol/lab/content/basic-blockchain/","title":"Basic Peer to peer blockchain","text":"<ul> <li>Peer to peer network</li> <li>Synchronise peers inside the network</li> <li>Mine a block and send it to the other peers</li> <li>Have a basic wallet and add money to it when we mine a block</li> <li>Send transactions and approve them into blockchain</li> </ul>"},{"location":"chapters/rust/content/cryptozombies/","title":"CryptoZombies","text":"<p>CryptoZombies is an interactive and gamified platform designed to teach blockchain and Smart Contract development using the Rust or Solidity programming language. It uses a series of coding lessons where you will build your own blockchain-based zombie-themed game step by step. Each lesson adds elements to a zombie game, making the learning process engaging and fun.</p> <p>Please follow the MultiversX CryptoZombie tutorial.</p>"},{"location":"chapters/rust/content/cryptozombies/#bonus","title":"Bonus","text":"<p>If you wish to learn other blockchains, please follow courses for Solidity, Optimism, zkSync, Tron, Chainlink, etc.</p>"},{"location":"chapters/rust/content/rust/","title":"Learning Rust and Rust in Smart Contracts","text":""},{"location":"chapters/rust/content/rust/#objectives","title":"Objectives","text":"<p>In this section you will learn about Rust: * The Basics; * Basic Control Flow; * Basic Data Structure Types; * Generic Types; * Ownership &amp; Borrowing Data; * Object Oriented Programming - Traits; * Cryptozombies - learn SC development via an interactive and gamified platform.</p> <p>There will be 2 approaches: 1. Tour of Rust - a step by step guide through the features of the Rust programming language; 2. Cryptozombies - learn Rust and Smart Contract programming in a fun and easy way;</p>"},{"location":"chapters/rust/content/tour-of-rust/","title":"Tour of Rust","text":"<p>In this section you will learn Rust via Tour of Rust tutorial. You can find this guide in multiple languages including English and Romanian.</p> <p>The following sections are useful for Smart Contract programming: * Chapter 1 - The Basics; * Chapter 2 - Basic Control Flow; * Chapter 3 - Basic Data Structure Types; * Chapter 4 - Generic Types; * Chapter 5 - Ownership &amp; Borrowing Data; * Chapter 7 - Object Oriented Programming (Traits).</p> <p>We recommend going through the whole Tour of Rust tutorial. Moreover, to fully understand the Rust Programming Language, please go through the Rust Programming Language book.</p>"},{"location":"chapters/security/lab/content/","title":"Security in Blockchains","text":"<p>TODO: Reproduce attacks</p>"},{"location":"chapters/smart-contracts/lab/content/adder/","title":"The Adder SC","text":"<p>The Adder smart contract is a simple smart contract with an <code>add</code> functionality and a global variable that can be incremented.</p> <pre><code>/// One of the simplest smart contracts possible,\n/// it holds a single variable in storage, which anyone can increment.\n#[multiversx_sc::contract]\npub trait Adder {\n    #[view(getSum)]\n    #[storage_mapper(\"sum\")]\n    fn sum(&amp;self) -&gt; SingleValueMapper&lt;BigUint&gt;;\n\n    #[init]\n    fn init(&amp;self, initial_value: BigUint) {\n        self.sum().set(initial_value);\n    }\n\n    #[upgrade]\n    fn upgrade(&amp;self, initial_value: BigUint) {\n        self.init(initial_value);\n    }\n\n    /// Add desired amount to the storage variable.\n    #[endpoint]\n    fn add(&amp;self, value: BigUint) {\n        self.sum().update(|sum| *sum += value);\n    }\n}\n</code></pre> <p>We notice 4 functions: * sum - this is a global variable, a <code>SingleValueMapper</code> (a single value) of type BigUint (unsigned integer); * init - the constructor; * add - function that increments the global variable (<code>sum</code>) with the <code>value</code> parameter; * upgrade - function executed when upgrading the contract.</p> <p>We notice 5 types of annotations: * <code>#[view(getSum)]</code> - this is a function that allows you to read the storage variable by calling the function <code>getSum</code>; * <code>#[storage_mapper(\"sum\")]</code> - this is a global variable (also called a storage) stored at the contract address; * <code>#[init]</code> - the constructor function; this is called when deploying the contract; * <code>#[upgrade]</code>  - this function is called when upgrading the contract; * <code>#[endpoint]</code> - an endpoint is a function callable directly by the user; A function not having this annotation will not be exposed publicly.</p> <p>Here is the smart contract code listed above and here are all the files needed for compilation. </p> <p>Let's compile the contract:</p> <pre><code>costin@Byblos:~/mvx/mx-contracts-rs/contracts/adder$ sc-meta all build\n /home/costin/mvx/mx-contracts-rs/contracts/adder\n\nFound 1 contract crates.\n\n(1/1)\nIn /home/costin/mvx/mx-contracts-rs/contracts/adder/meta\nCalling `cargo run build`\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s\n     Running `/home/costin/mvx/mx-contracts-rs/target/debug/adder-meta build`\nUsing workspace target directory: /home/costin/mvx/mx-contracts-rs/target ...\nBuilding adder.wasm in /home/costin/mvx/mx-contracts-rs/contracts/adder/wasm ...\nRUSTFLAGS=\"-C link-arg=-s -C link-arg=-zstack-size=131072\" cargo build --target=wasm32-unknown-unknown --release --target-dir /home/costin/mvx/mx-contracts-rs/target\n   Compiling proc-macro2 v1.0.86\n   Compiling unicode-ident v1.0.13\n   Compiling smallvec v1.13.2\n   Compiling autocfg v1.4.0\n   Compiling hex v0.4.3\n   Compiling endian-type v0.1.2\n   Compiling arrayvec v0.7.6\n   Compiling unwrap-infallible v0.1.5\n   Compiling bitflags v2.6.0\n   Compiling hex-literal v0.4.1\n   Compiling nibble_vec v0.1.0\n   Compiling radix_trie v0.2.1\n   Compiling num-traits v0.2.19\n   Compiling quote v1.0.37\n   Compiling syn v2.0.77\n   Compiling multiversx-sc-codec-derive v0.21.0\n   Compiling multiversx-sc-derive v0.53.2\n   Compiling multiversx-sc-codec v0.21.0\n   Compiling multiversx-sc v0.53.2\n   Compiling adder v0.0.0 (/home/costin/mvx/mx-contracts-rs/contracts/adder)\n   Compiling multiversx-sc-wasm-adapter v0.53.2\n   Compiling adder-wasm v0.0.0 (/home/costin/mvx/mx-contracts-rs/contracts/adder/wasm)\n    Finished `release` profile [optimized] target(s) in 8.69s\nCopying /home/costin/mvx/mx-contracts-rs/target/wasm32-unknown-unknown/release/adder_wasm.wasm to ../output/adder.wasm ...\nCalling wasm-opt on ../output/adder.wasm ...\nExtracting imports to ../output/adder.imports.json ...\nChecking EI version: 1.3 ... OK\nPacking ../output/adder.mxsc.json ...\nContract size: 696 bytes.\n</code></pre> <p>Let's check the contract: <pre><code>costin@Byblos:~/mvx/mx-contracts-rs/contracts/adder$ ls -l output/\ntotal 16\n-rw-rw-r-- 1 costin costin 1792 nov  7 13:28 adder.abi.json\n-rw-rw-r-- 1 costin costin  262 nov  7 13:28 adder.imports.json\n-rw-rw-r-- 1 costin costin 4070 nov  7 13:28 adder.mxsc.json\n-rwxrwxr-x 1 costin costin  696 nov  7 13:28 adder.wasm\n</code></pre></p> <p>We notice that the resulted contract (<code>adder.wasm</code>) has 696 bytes.</p>"},{"location":"chapters/smart-contracts/lab/content/adder/#practice","title":"Practice","text":"<ul> <li>Compile the Adder contract.</li> </ul>"},{"location":"chapters/smart-contracts/lab/content/cargo_deploy/","title":"Smart Contract deployment via Rust","text":"<p>Let's deploy our smart contract(SC) on the blockchain. We will deploy the <code>adder</code> contract from the previous section.</p> <p>In the repo there is a folder named interact.</p> <p>Let's take a look into the basic_interact_cli.rs file: <pre><code>#[derive(Clone, PartialEq, Eq, Debug, Subcommand)]\npub enum InteractCliCommand {\n    #[command(name = \"add\", about = \"Add value\")]\n    Add(AddArgs),\n    #[command(name = \"deploy\", about = \"Deploy contract\")]\n    Deploy,\n    #[command(name = \"feed\", about = \"Feed contract EGLD\")]\n    Feed,\n    #[command(name = \"multi-deploy\", about = \"Multiple deploy contracts\")]\n    MultiDeploy(MultiDeployArgs),\n    #[command(name = \"sum\", about = \"Print sum\")]\n    Sum,\n}\n</code></pre></p> <p>We have 5 arguments we can use to interact with this contract. We will <code>deploy</code> for now.</p> <p>Let's take a look into the basic_interact.rs file:</p> <pre><code>async fn main() {\n    env_logger::init();\n\n    let mut basic_interact = AdderInteract::init().await;\n\n    let cli = basic_interact_cli::InteractCli::parse();\n    match &amp;cli.command {\n        Some(basic_interact_cli::InteractCliCommand::Add(args)) =&gt; {\n            basic_interact.add(args.value).await;\n        }\n        Some(basic_interact_cli::InteractCliCommand::Deploy) =&gt; {\n            basic_interact.deploy().await;\n        }\n        Some(basic_interact_cli::InteractCliCommand::Feed) =&gt; {\n            basic_interact.feed_contract_egld().await;\n        }\n        Some(basic_interact_cli::InteractCliCommand::MultiDeploy(args)) =&gt; {\n            basic_interact.multi_deploy(&amp;args.count).await;\n        }\n        Some(basic_interact_cli::InteractCliCommand::Sum) =&gt; {\n            basic_interact.print_sum().await;\n        }\n        None =&gt; {}\n    }\n}\n</code></pre>"},{"location":"chapters/smart-contracts/lab/content/cargo_deploy/#sc-deploy","title":"SC Deploy","text":"<p>The main function checks the arguments and calls the designated function. We will be using <code>deploy</code> async function to deploy our <code>adder</code> smart contract: <pre><code>    async fn deploy(&amp;mut self) {\n        // warning: multi deploy not yet fully supported\n        // only works with last deployed address\n\n        self.set_state().await;\n\n        let new_address = self\n            .interactor\n            .tx()\n            .from(&amp;self.wallet_address)\n            .typed(adder_proxy::AdderProxy)\n            .init(0u32)\n            .code(&amp;self.adder_code)\n            .returns(ReturnsNewBech32Address)\n            .prepare_async()\n            .run()\n            .await;\n\n        println!(\"new address: {new_address}\");\n        self.state.set_adder_address(new_address);\n    }\n</code></pre></p> <p>The interactor will make a call to the blockchain from a wallet address. This is a test address and it's referenced from the MultiversX Framework SDK.</p> <p>Let's deploy a contract: <pre><code>$ cargo run deploy\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s\n     Running `/Users/costincarabas/mvx/mx-contracts-rs/target/debug/basic-interact deploy`\nwallet address: erd1uv40ahysflse896x4ktnh6ecx43u7cmy9wnxnvcyp7deg299a4sq6vaywa\nsender's recalled nonce: 5498\n-- tx nonce: 5498\nsc deploy tx hash: 4133385c40fee378f5fc1b6318f53302750c2403a9d02e00ed727c35ba9b41ba\ndeploy address: erd1qqqqqqqqqqqqqpgqef8xmsatt4tkf5ycv538a2kme3h7dy37a4sqygv9p5\n</code></pre></p> <p>Notice the: * sender's nonce - how many transactions he initiated; * sc deploy tx hash - the hash of the transaction where we deployed the code on a new SC; * deploy address - the address where the new SC is located.</p> <p>Question 1: Will this transaction show on the Explorer?</p> <p>Question 2: Will all the validators executee this transaction?</p>"},{"location":"chapters/smart-contracts/lab/content/cargo_deploy/#sc-query","title":"SC Query","text":"<p>Let's read the storage from the SC:</p> <pre><code>    async fn print_sum(&amp;mut self) {\n        let sum = self\n            .interactor\n            .query()\n            .to(self.state.current_adder_address())\n            .typed(adder_proxy::AdderProxy)\n            .sum()\n            .returns(ReturnsResultUnmanaged)\n            .prepare_async()\n            .run()\n            .await;\n\n        println!(\"sum: {sum}\");\n    }\n</code></pre> <p>Notice that we will make a <code>query</code> on the blockchain to retrieve information.</p> <p>Question 1: Will this transaction show on the Explorer?</p> <p>Question 2: Will all the validators execute this transaction?</p> <p>Remember from the <code>main</code> function and the <code>basic_interact_cli.rs</code> file that we need to call the <code>sum</code> parameter: <pre><code>$ cargo run sum\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.36s\n     Running `/Users/costincarabas/mvx/mx-contracts-rs/target/debug/basic-interact sum`\nsum: 0\n</code></pre></p> <p>The <code>sum</code> storage is 0, because this was the value used by the interactor.</p>"},{"location":"chapters/smart-contracts/lab/content/cargo_deploy/#sc-executee-endpoint","title":"SC executee endpoint","text":"<p>Let's executee our first endpoint, the <code>add</code> function:</p> <pre><code>    async fn add(&amp;mut self, value: u64) {\n        self.interactor\n            .tx()\n            .from(&amp;self.wallet_address)\n            .to(self.state.current_adder_address())\n            .typed(adder_proxy::AdderProxy)\n            .add(value)\n            .prepare_async()\n            .run()\n            .await;\n\n        println!(\"successfully performed add\");\n    }\n</code></pre> <p>Notice that we use the <code>tx</code> functionality of the interactor. We call the <code>add</code> endpoint of the smart contract.</p> <p>Please inspect basic_interact.rs file one more time:</p> <pre><code>pub struct AddArgs {\n    /// The value to add\n    #[arg(short = 'v', long = \"value\", verbatim_doc_comment)]\n    pub value: u64,\n}\n</code></pre> <p>We must provide a parameter <code>-v $value</code> or <code>--value $value</code>. Let's try it both ways:</p> <pre><code>$ cargo run add --value 2\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s\n     Running `/Users/costincarabas/mvx/mx-contracts-rs/target/debug/basic-interact add --value 2`\nsender's recalled nonce: 5499\n-- tx nonce: 5499\nsc call tx hash: 2b85ad0af8bed72f415abcf03ed1615ab2e72c33354400f66aafd22346d1871c\nsuccessfully performed add\n</code></pre> <p>Notice: * tx nonce - this is the sender's nonce; * sc call tx hash - this is the hash of the transaction we generated;</p> <p>We recommend checking every action you perform: <pre><code> $ cargo run sum\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s\n     Running `/Users/costincarabas/mvx/mx-contracts-rs/target/debug/basic-interact sum`\nsum: 2\n</code></pre></p> <p>Let's try the other way (<code>-v $value</code>):</p> <pre><code> $ cargo run add -v 4\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.10s\n     Running `/Users/costincarabas/mvx/mx-contracts-rs/target/debug/basic-interact add -v 4`\nsender's recalled nonce: 5500\n-- tx nonce: 5500\nsc call tx hash: a7f07975deb4ea01b19572146adb68b1b83abd1e7ed0396475cf389641ab03b5\nsuccessfully performed add\n</code></pre> <p>Let's check that the storage was incremented: <pre><code> $ cargo run sum\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s\n     Running `/Users/costincarabas/mvx/mx-contracts-rs/target/debug/basic-interact sum`\nsum: 6\n</code></pre></p> <p>Question 1: Will these transactions (endpoint calling) show on the Explorer?</p> <p>Question 2: Will all the validators executee these transactions (endpoint calling)?</p>"},{"location":"chapters/smart-contracts/lab/content/empty/","title":"The Empty SC","text":"<p>The smallest smart contract is an empty smart contract with no functionalities. Compiled, it is a binary that is accepted by the blockchain.</p> <pre><code>/// An empty contract. To be used as a template when starting a new contract from scratch.\n#[multiversx_sc::contract]\npub trait EmptyContract {\n    #[init]\n    fn init(&amp;self) {}\n}\n</code></pre> <p>Here is the smart contract code listed above and here are all the files needed for compilation. </p> <p>We have the annotation <code>#[init]</code> where we specify the constructor function. Only one constructor is allowed per smart contract.</p> <p>Let's build the smart contract:</p> <pre><code>costin@Byblos:~/mvx/mx-contracts-rs/contracts/empty$ sc-meta all build\n /home/costin/mvx/mx-contracts-rs/contracts/empty\n\nFound 1 contract crates.\n\n(1/1)\nIn /home/costin/mvx/mx-contracts-rs/contracts/empty/meta\nCalling `cargo run build`\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s\n     Running `/home/costin/mvx/mx-contracts-rs/target/debug/empty-meta build`\nUsing workspace target directory: /home/costin/mvx/mx-contracts-rs/target ...\nBuilding empty.wasm in /home/costin/mvx/mx-contracts-rs/contracts/empty/wasm ...\nRUSTFLAGS=\"-C link-arg=-s -C link-arg=-zstack-size=131072\" cargo build --target=wasm32-unknown-unknown --release --target-dir /home/costin/mvx/mx-contracts-rs/target\n   Compiling proc-macro2 v1.0.86\n   Compiling unicode-ident v1.0.13\n   Compiling hex v0.4.3\n   Compiling smallvec v1.13.2\n   Compiling autocfg v1.4.0\n   Compiling endian-type v0.1.2\n   Compiling arrayvec v0.7.6\n   Compiling unwrap-infallible v0.1.5\n   Compiling bitflags v2.6.0\n   Compiling hex-literal v0.4.1\n   Compiling nibble_vec v0.1.0\n   Compiling radix_trie v0.2.1\n   Compiling num-traits v0.2.19\n   Compiling quote v1.0.37\n   Compiling syn v2.0.77\n   Compiling multiversx-sc-codec-derive v0.21.0\n   Compiling multiversx-sc-derive v0.53.2\n   Compiling multiversx-sc-codec v0.21.0\n   Compiling multiversx-sc v0.53.2\n   Compiling empty v0.0.0 (/home/costin/mvx/mx-contracts-rs/contracts/empty)\n   Compiling multiversx-sc-wasm-adapter v0.53.2\n   Compiling empty-wasm v0.0.0 (/home/costin/mvx/mx-contracts-rs/contracts/empty/wasm)\n    Finished `release` profile [optimized] target(s) in 8.17s\nCopying /home/costin/mvx/mx-contracts-rs/target/wasm32-unknown-unknown/release/empty_wasm.wasm to ../output/empty.wasm ...\nCalling wasm-opt on ../output/empty.wasm ...\nExtracting imports to ../output/empty.imports.json ...\nChecking EI version: 1.3 ... OK\nPacking ../output/empty.mxsc.json ...\nContract size: 231 bytes.\n</code></pre> <p>The resulted contract is <code>output/empty.wasm</code>, a WebAseembly binary module that is only 232 bytes:</p> <pre><code>costin@Byblos:~/mvx/mx-contracts-rs/contracts/empty$ ls -l output/\ntotal 16\n-rw-rw-r-- 1 costin costin  868 nov  7 12:17 empty.abi.json\n-rw-rw-r-- 1 costin costin   60 nov  7 12:17 empty.imports.json\n-rw-rw-r-- 1 costin costin 1774 nov  7 12:17 empty.mxsc.json\n-rwxrwxr-x 1 costin costin  231 nov  7 12:17 empty.wasm\n</code></pre>"},{"location":"chapters/smart-contracts/lab/content/empty/#practice","title":"Practice","text":"<ul> <li>Clone the Empty SC repo;</li> <li>Compile the contract.</li> </ul>"},{"location":"chapters/smart-contracts/lab/content/events/","title":"Events","text":"<p>In this section you will learn what Smart Contract Events are, how to see what events were emitted in a transaction and how to emit one yourself.</p> <p>Key Takeaways: * Events in smart contracts serve as a communication mechanism between the contract and user interfaces; * By emitting events, smart contracts can notify external applications or listeners about specific actions or changes; * Events play a key role in facilitating effective interaction with user interfaces while ensuring secure automated execution of code-based agreements.</p>"},{"location":"chapters/smart-contracts/lab/content/events/#example-of-events","title":"Example of events","text":"<p>Notice the Logs section near the Transaction Details. </p> <p>This section shows all the events this transaction emitted. Notice that most transactions have this Logs section.</p> <p></p> <p>Let's open this tab and inspect the Events</p> <p></p> <p>Notice there are 4 data fields: * <code>SBPT-774fbd</code> - the token ID; * <code>1</code> - the nonce; * <code>1</code> - the value (the Smart display feature doesn't know how to interpret that but the Decimal option does); * <code>erd1mqa9wttlzwwdvwgk9dzsfdn79lv5raw0tfe9ynvn0dg92hpruvaqhhd2gx</code> - the destination address.</p> <p>Let's inspect a more complex operation and check all the log events. Here is the link to the transaction.</p> <p></p> <p>Notice that the transaction has 4 transfers and 1 burn operations. Let's inspect the logs:</p> <p></p> <p>The first transaction is an <code>ESDTTransfer</code> for the token <code>USDC-c76f1f</code> which has 6 decimals; therefore 580345261 is equal to 580,345261$. You can match the events to the Token Operations from the Transacton Details.</p> <p>You can check the <code>deposit_swap_fees_event</code> code here.</p> <p>Notice the burn event below. Keep in mind that <code>MEX-455c57</code> has 18 decimals. </p> <p>Here is the code for the <code>swap_no_fee_and_forward</code> event.</p>"},{"location":"chapters/smart-contracts/lab/content/events/#writing-your-own-event-in-the-smart-contract","title":"Writing your own event in the Smart Contract","text":"<p>The structure of an event is: <pre><code>    #[event(\"your_event_name\")]\n    fn the_function_you_call_when_you_want_to_emit_en_event(\n        &amp;self,\n        #[indexed] field1: &amp;TokenIdentifier,\n        #[indexed] field2: &amp;ManagedAddress,\n        #[indexed] field3: u64,\n        #[indexed] field4: BigUint,\n    );\n</code></pre></p> <p>And when you want to emit an event, just call the function: <pre><code>    self.the_function_you_call_when_you_want_to_emit_en_event(field1, field2, field3, field4);\n</code></pre></p>"},{"location":"chapters/smart-contracts/lab/content/events/#task","title":"Task","text":"<p>Last time you interacted with the ping-pong contract. This time, you have to inspect the contract and call an endpoint that emits an event. Don't forget to check the logs!</p>"},{"location":"chapters/smart-contracts/lab/content/mxpy_deploy/","title":"Smart Contract deployment via Python (mxpy)","text":"<p>Let's deploy our smart contract on the blockchain. For this, we will use <code>mxpy</code> tools previously installed. We will deploy the <code>adder</code> contract from the previous section.</p> <p>In the repo there is a folder named interaction.</p> <p>Let's inspect the <code>testnet.snippets.sh</code> file:</p> <pre><code>ALICE=\"${USERS}/alice.pem\"\nADDRESS=$(mxpy data load --key=address-testnet)\nPROJECT=\"../output/adder.wasm\"\nDEPLOY_TRANSACTION=$(mxpy data load --key=deployTransaction-testnet)\nPROXY=https://testnet-api.multiversx.com\n\ndeploy() {\n    mxpy --verbose contract deploy --project=${PROJECT} --recall-nonce --pem=${ALICE} --gas-limit=50000000 --arguments 0 --send --outfile=\"deploy-testnet.interaction.json\" --proxy=${PROXY} --chain=T || return\n\n    TRANSACTION=$(mxpy data parse --file=\"deploy-testnet.interaction.json\" --expression=\"data['emittedTransactionHash']\")\n    ADDRESS=$(mxpy data parse --file=\"deploy-testnet.interaction.json\" --expression=\"data['contractAddress']\")\n\n    mxpy data store --key=address-testnet --value=${ADDRESS}\n    mxpy data store --key=deployTransaction-testnet --value=${TRANSACTION}\n\n    echo \"\"\n    echo \"Smart contract address: ${ADDRESS}\"\n}\n\nadd() {\n    read -p \"Enter number: \" NUMBER\n    mxpy --verbose contract call ${ADDRESS} --recall-nonce --pem=${ALICE} --gas-limit=5000000 --function=\"add\" --arguments ${NUMBER} --send --proxy=${PROXY} --chain=T\n}\n\ngetSum() {\n    mxpy --verbose contract query ${ADDRESS} --function=\"getSum\" --proxy=${PROXY}\n}\n</code></pre> <p>This file helps us to easily make deployment and transactions on the blockchain.</p> <p>First, let's modify the <code>ALICE</code> variable and put our own <code>pem</code> file.</p> <p>After that use <code>source</code> command or <code>.</code> in bash to interpret the file: <pre><code>costin@Byblos:~/mvx/mx-contracts-rs/contracts/adder/interaction$ . testnet.snippets.sh \n</code></pre></p> <p>This will load all the variables and functions in the environment. Now we can call the <code>deploy</code> function: <pre><code>costin@Byblos:~/mvx/mx-contracts-rs/contracts/adder/interaction$ deploy \nINFO     cli.contracts: Contract address: erd1qqqqqqqqqqqqqpgq9ss82g55h3k96898kmdtp8am3a4qaefcuvaqutqjjd\nINFO     utils: View this contract address in the MultiversX Testnet Explorer: https://testnet-explorer.multiversx.com/accounts/erd1qqqqqqqqqqqqqpgq9ss82g55h3k96898kmdtp8am3a4qaefcuvaqutqjjd\nINFO     utils: View this transaction in the MultiversX Testnet Explorer: https://testnet-explorer.multiversx.com/transactions/761d6fb8b42cb0eed546f9c9f55ffbf2457f3fc35854e6030162fb65b6b840df\nWARNING  cli.data: Never use this command to store sensitive information! Data is unencrypted.\nINFO     cli.data: Data has been stored at key = 'address-testnet', in partition = '*'.\nWARNING  cli.data: Never use this command to store sensitive information! Data is unencrypted.\nINFO     cli.data: Data has been stored at key = 'deployTransaction-testnet', in partition = '*'.\n\nSmart contract address: erd1qqqqqqqqqqqqqpgq9ss82g55h3k96898kmdtp8am3a4qaefcuvaqutqjjd\n</code></pre></p> <p>Now we have performed a deployment of the wasm binary (our adder contract) in the blockchain.</p> <p>Notice the MultiversX Testnet Explorer: https://testnet-explorer.multiversx.com/transactions/761d6fb8b42cb0eed546f9c9f55ffbf2457f3fc35854e6030162fb65b6b840df. Click on the link to see your transaction. </p> <p>Notice the Smart contract address: erd1qqqqqqqqqqqqqpgq9ss82g55h3k96898kmdtp8am3a4qaefcuvaqutqjjd. Go to the Testnet Explorer and search for your SC address.</p> <p>Notice the contract deployed on testnet:</p> <p></p> <p>Observe the fields Owner, Deployed (timestamp).</p>"},{"location":"chapters/smart-contracts/lab/content/mxpy_sc_call/","title":"Smart Contract call","text":"<p>Now let's call our previous <code>adder</code> smart contract.</p> <p>Inspect the <code>deploy</code> function in our <code>testnet.snippets.sh</code>. Observer that we provided the arguments: <code>--arguments 0</code>. In our <code>init</code> function, we provided the argument and saved it in our <code>sum</code> global variable (storage):</p> <pre><code>#[init]\nfn init(&amp;self, initial_value: BigUint) {\n    self.sum().set(initial_value);\n}\n</code></pre> <p>Therefore in the SC there is a <code>sum</code> storage initialized with 0.</p> <p>Let's call the <code>add</code> endpoint to add a value to our storage: <pre><code>/mvx/mx-contracts-rs/contracts/adder/interaction$ add \nEnter number: 2\nINFO     utils: View this transaction in the MultiversX Testnet Explorer: https://testnet-explorer.multiversx.com/transactions/2a906bc468008706f928cc5b7a669570c71556c604ae8d1ef2dfdfb100636f74                         \n{\n    \"emittedTransaction\": {\n        \"nonce\": 313,\n        \"value\": \"0\",\n        \"receiver\": \"erd1qqqqqqqqqqqqqpgq9ss82g55h3k96898kmdtp8am3a4qaefcuvaqutqjjd\",\n        \"sender\": \"erd1mqa9wttlzwwdvwgk9dzsfdn79lv5raw0tfe9ynvn0dg92hpruvaqhhd2gx\",\n        \"senderUsername\": \"\",\n        \"receiverUsername\": \"\",\n        \"gasPrice\": 1000000000,\n        \"gasLimit\": 5000000,\n        \"data\": \"YWRkQDAy\",\n        \"chainID\": \"T\",\n        \"version\": 2,\n        \"options\": 0,\n        \"guardian\": \"\",\n        \"signature\": \"187f19d7daad9b75f3f6469b56698ab84442786f4a592f4cb86efb858d40d63e75307964a4dd838bf114303427e3e4d2c9322936de3ee520c0ee9878bd2a8c0b\",\n        \"guardianSignature\": \"\"\n    },\n    \"emittedTransactionData\": \"add@02\",\n    \"emittedTransactionHash\": \"2a906bc468008706f928cc5b7a669570c71556c604ae8d1ef2dfdfb100636f74\",\n    \"contractAddress\": \"erd1qqqqqqqqqqqqqpgq9ss82g55h3k96898kmdtp8am3a4qaefcuvaqutqjjd\"\n}\n</code></pre></p> <p>Inspect the MultiversX Testnet Explorer to see the transaction.</p> <p>Let's call the <code>getSum</code> view function to read from the storage:</p> <pre><code>costin@Byblos:~/mvx/mx-contracts-rs/contracts/adder/interaction$ getSum \n[\n    \"02\"\n]\n</code></pre> <p>Notice that the view functions (the queries) are not transactions on blockchain. We didn't pay any gas for this. We didn't create any transaction.</p>"},{"location":"chapters/smart-contracts/lab/content/neversea/","title":"Never Sea Festival Smart Contract","text":"<p>You are the NeverSea Festival 2025 organizers and you decide to create the registration via blockchain. Starting from Smart Contract template you have to add more features to coordinate the event.</p> <p>You can use the empty SC template: <pre><code>$ sc-meta new --name my_neversea_2025 --template empty\n[...]\n\n$ ll my-neversea-2025/\ntotal 16\ndrwxr-xr-x@  8 costincarabas  staff   256B Nov  6 04:21 .\ndrwxr-x---+ 54 costincarabas  staff   1.7K Nov  6 04:21 ..\n-rw-r--r--@  1 costincarabas  staff   343B Nov  6 04:21 Cargo.toml\ndrwxr-xr-x@  4 costincarabas  staff   128B Nov  6 04:21 meta\n-rw-r--r--@  1 costincarabas  staff    26B Nov  6 04:21 multiversx.json\ndrwxr-xr-x@  3 costincarabas  staff    96B Nov  6 04:21 scenarios\ndrwxr-xr-x@  3 costincarabas  staff    96B Nov  6 04:21 src\ndrwxr-xr-x@  4 costincarabas  staff   128B Nov  6 04:21 tests\n</code></pre></p> <p>There are several other templates: <pre><code>$ sc-meta templates\nempty\nping-pong-egld\ncrypto-zombies\nadder\n</code></pre></p>"},{"location":"chapters/smart-contracts/lab/content/neversea/#compile-the-smart-contract-template","title":"Compile the Smart Contract template","text":"<p>To check that the contract was successfully built, verify that there was a wasm (WebAssembly) file generate: output/your-contract-name.wasm. This is the compiled code of your contract.</p> <p>NOTE</p> <p>For any further actions, please check the compilation on your local machine (and the deployment on the explorer, if it's the case). Do not assume that the contract was successfully compiled and deployed.</p>"},{"location":"chapters/smart-contracts/lab/content/neversea/#any-modification-of-the-contract-must-be-succeeded-by-a-compilation-and-deployment","title":"Any modification of the contract must be succeeded by a compilation and deployment!","text":""},{"location":"chapters/smart-contracts/lab/content/neversea/#constructor","title":"Constructor","text":"<p>Implement the <code>init</code> function so that it will take an argument that it's the registration fee and set a <code>registration_fee</code> storage. Implement the <code>upgrade</code> function so that it won't take any argument.</p>"},{"location":"chapters/smart-contracts/lab/content/neversea/#storages","title":"Storages","text":"<p>Add 2 storages: * <code>participants</code> - a set of addresses (you can use <code>ManagedAddress</code>) that stores the participants list; * <code>registration_fee</code> - you can use <code>BigUint</code> to store the fee.</p>"},{"location":"chapters/smart-contracts/lab/content/neversea/#add-endpoints","title":"Add endpoints","text":"<p>Add a <code>register</code> endpoint where clients will pay the fee via EGLD to register to the festival. Add a <code>update_registration_fees</code> endpoint where the owner can update the fee. Use <code>#[only_owner]</code> annotation so that the endpoint can be called only by the owner.</p>"},{"location":"chapters/smart-contracts/lab/content/neversea/#practice","title":"Practice","text":"<ul> <li>Make a contract call to register a user;</li> <li>Make a contract call to view the registered users;</li> <li>Modify the registration endpoint to enable VIP access;</li> <li>Create a new storage mapper registration_fee_vip;</li> <li>Create a new storage mapper vip_participants to save the VIP participants;</li> <li>In the registration endpoint, make a verification of the tokens received. If the tokens received is registration_fee_vip, add the user to vip_participants, if the amount is registration_fee, add them to participants, else, deny registration;</li> <li>Modify the registration fee to enable Early Bird and Full price access;</li> <li>Create a new endpoint that modifies the registration_fee and registration_fee_vip storage mapper. This endpoint should be call only by the owner.</li> <li>BONUS: Create a feature to enable 50% discount vouchers for friends and partners. Create a list of hardcoded discount codes. Create a new endpoint that receives a discount code as a parameter and registers a user with 50% discount.</li> </ul> <p>Hint Use <code>#[only_owner]</code> endpoint annotation.</p>"},{"location":"chapters/smart-contracts/lab/content/prerequisites/","title":"Prerequisites","text":"<p>All of these prerequisites were done at the first lab. You can skip this section if you have already done this.</p>"},{"location":"chapters/smart-contracts/lab/content/prerequisites/#install-mxpy-blockchain-interaction","title":"Install mxpy - blockchain interaction","text":"<p>We use <code>mxpy</code> to interact with the blockchain.</p> <p>To install <code>mxpy</code> run: <pre><code>pipx install multiversx-sdk-cli --force\n</code></pre></p> <p>To check the successful installation: <pre><code>$ mxpy --version\nMultiversX Python CLI (mxpy) 9.8.1\n</code></pre></p> <p>If you encounter any errors, follow the guide here.</p>"},{"location":"chapters/smart-contracts/lab/content/prerequisites/#install-sc-meta-contract-interaction","title":"Install sc-meta - contract interaction","text":"<p>We use <code>sc-meta</code> to compile the contracts and to upgrade the dependencies.</p> <p>To install <code>sc-meta</code>, simply call: <pre><code>$ cargo install multiversx-sc-meta\n</code></pre></p> <p>To check for successful installation: <pre><code>$ sc-meta --version\nmultiversx-sc-meta 0.54.0\n</code></pre></p> <p>If you encounter any errors, follow the guide here.</p>"},{"location":"chapters/smart-contracts/lab/content/prerequisites/#contracts-examples","title":"Contracts examples","text":"<p>Here is a list of Smart Contract examples. We will use part of them to understand smart contracts on MultiversX.</p>"},{"location":"chapters/smart-contracts/lab/content/rust_interactors/","title":"Creating a Rust interactor","text":"<p>Rust interactors are used to interact with the blockchain via Rust.</p> <p>Let's do this for the empty SC:</p> <pre><code>sc-meta all snippets\n /Users/costincarabas/mvx/mx-contracts-rs/contracts/empty\n\nFound 1 contract crates.\n\n(1/1)\nIn /Users/costincarabas/mvx/mx-contracts-rs/contracts/empty/meta\nCalling `cargo run snippets`\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.16s\n     Running `/Users/costincarabas/mvx/mx-contracts-rs/target/debug/empty-meta snippets`\n</code></pre> <p>A new folder <code>interactor</code> was created. This will generate code for all the endpoints and view functions you created.</p> <p>As this is a new and separate Rust binary, you must add it to the main <code>Cargo.toml</code>'s members:</p> <pre><code>members = [\n[...]\n  \"contracts/empty/interactor\",\n[...]\n]\n</code></pre> <p>Now you can use it: <pre><code>$ cargo run deploy\n[...]\nsender's recalled nonce: 10595\n-- tx nonce: 10595\nsc deploy tx hash: a17a4f51305b6f6dd9c01ec4986d0f90266ef560599b15af613e9aadd816e705\ndeploy address: erd1qqqqqqqqqqqqqpgqchszakc8fm44c2rndjh09xeuh829g4tgd8sskk0m5e\n</code></pre></p>"},{"location":"chapters/smart-contracts/lab/content/rust_interactors/#practice","title":"Practice","text":"<ul> <li>Create an interactor for you Empty contract.</li> </ul>"},{"location":"chapters/template-chapter/template-topic/drills/","title":"Practice: Baby Steps","text":"<p>We recommend that for practice, you add a subsection for the exercises. This will make it so you can delimit the exercises from the lab's text.</p> <ol> <li> <p>You can number the exercises as such.    And have the text roll over to the next line.</p> </li> <li> <p>This is a second numbered exercise.</p> </li> </ol> <p>Be careful!    You can even link to other chapters internally like this</p> <p>Another neat feature is that you can add inline code that uses language specific highlight.</p> <pre><code>with event:\n    while len(messages) == 0:\n        event.wait()\n</code></pre> <p>For now, a quiz can only be linked to as such: Quiz 1</p>"},{"location":"chapters/template-chapter/template-topic/drills/questions/","title":"TODO question","text":""},{"location":"chapters/template-chapter/template-topic/drills/questions/#question-text","title":"Question Text","text":"<p>Which answer is the correct answer?</p>"},{"location":"chapters/template-chapter/template-topic/drills/questions/#question-answers","title":"Question Answers","text":"<ul> <li>Bad answer 1</li> <li>Correct answer</li> <li>Bad answer 2</li> <li>Bad answer 3</li> </ul>"},{"location":"chapters/template-chapter/template-topic/drills/questions/#feedback","title":"Feedback","text":"<p>Correct answer is the correct answer</p> <pre><code>echo \"Guess why\"\n</code></pre>"},{"location":"chapters/template-chapter/template-topic/guides/","title":"Guides","text":""},{"location":"chapters/template-chapter/template-topic/guides/#executable-paths","title":"Executable Paths","text":"<p>Single instances of commands should be written using monotype fonts such as this <code>ls</code>.</p> <p>For longer outputs, you will use the following syntax:</p> <pre><code>student@os:~$ which ls\n/usr/bin/ls\n\nstudent@os:~$ file /usr/bin/ls\n/usr/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=6e3da6f0bc36b6398b8651bbc2e08831a21a90da, for GNU/Linux 3.2.0, stripped\n</code></pre>"},{"location":"chapters/template-chapter/template-topic/reading/","title":"Template Chapter","text":"<p>This is an instance of a lab placeholder. This will be used to showcase the different highlights of the syntax.</p> <p>This is another sentence</p> <p>In order to use links to to outside resources, you can add them as such.</p> <p>This is a list of all the best cuisines in the world - Indian - Italian - French</p> <p>In order to make emphasize keywords, you can use bold words. To suggest a more metaphorical and less literal meaning of a phrase, you can use italic words.</p>"},{"location":"chapters/template-chapter/template-topic/reading/#section-the-first","title":"Section the first","text":"<p>For each skill learned in the lab, you will use a subsection which will touch up on new concepts.</p> <p>For integrating figures, you will use <code>![Example SVG](../media/app-os-cpu-interaction.svg)</code>.</p> <p></p>"},{"location":"chapters/template-chapter/template-topic/slides/content/","title":"Content","text":""},{"location":"chapters/template-chapter/template-topic/slides/content/#slides-hierarchy","title":"Slides hierarchy","text":""},{"location":"chapters/template-chapter/template-topic/slides/content/#slides-hierarchy_1","title":"Slides Hierarchy","text":"<ul> <li>Slides are organized in two levels<ul> <li>We use <code>---</code> in order to open up a new topic.    This leads to a new horizontal slide figuring a topic that can be expanded by vertical slides.</li> <li>We expand discussions on the same topic by vertical slides.    We use <code>----</code>, which adds a new vertical slide</li> </ul> </li> </ul>"},{"location":"chapters/template-chapter/template-topic/slides/content/#new-vertical-slide","title":"New Vertical Slide","text":"<ul> <li>This slide illustrates a new item of discussion on the matter of the slides hierarchy</li> </ul>"},{"location":"chapters/template-chapter/template-topic/slides/content/#animated-slides","title":"Animated Slides","text":"<ul> <li>You can even animate slides like this</li> </ul> <p><code>[1 - 2 | 3 - 4] student@os:~/.../compute/lecture/demo/create-process$ strace -e clone ./fork_exec clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7e83aa4810) = 5302 student@os:~/.../compute/lecture/demo/create-thread$ strace -e clone ./create_thread clone(child_stack=0x7f9ea7df0fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, tls=0x7f9ea7df1700, child_tidptr=0x7f9ea7df19d0) = 5389</code></p>"},{"location":"chapters/template-chapter/template-topic/slides/content/#tables","title":"Tables","text":"<p>You can include tables:</p> Advantages Disadvantages implemented by libraries implemented by the kernel blocking actions stall process blocking actions only stall current thread more mapped on one kernel thread provide support for user level threads Java, Python Linux KThreads, Windows threads"},{"location":"chapters/template-chapter/template-topic/slides/intro/","title":"TEMPLATE LECTURE","text":""},{"location":"chapters/template-chapter/template-topic/slides/intro/#included-slides","title":"Included slides","text":"<p>These slides have been included from the <code>intro.md</code> file. They also contain a list as follows: * item 1 * item 2</p>"},{"location":"chapters/template-chapter/template-topic/slides/intro/#slides-including-images","title":"Slides including images","text":"<ul> <li>A slide can also include images included using <code>![CPU Internals](../media/cpu-internals.jpg)</code></li> </ul>"},{"location":"chapters/template-chapter/template-topic/slides/intro/#all-processes-in-a-system","title":"All Processes in a System","text":"<pre><code>student@os:~$ ps -e | wc -l\n32\n\nstudent@os:~$ ps -e\n  PID TTY          TIME CMD\n    1 ?        00:00:00 init\n  914 ?        00:00:00 init\n 2582 ?        00:00:07 gpg-agent\n19812 ?        00:00:00 init\n19813 ?        00:00:00 init\n19814 pts/0    00:00:00 bash\n20650 ?        00:00:00 init\n20651 ?        00:00:00 init\n20652 pts/1    00:00:00 sh\n20653 pts/1    00:00:00 sh\n20658 pts/1    00:00:00 sh\n20661 pts/1    00:00:03 node\n20672 ?        00:00:00 init\n20673 ?        00:00:00 init\n20674 pts/2    00:00:00 node\n20681 pts/1    00:00:00 node\n20701 ?        00:00:00 init\n20702 ?        00:00:00 init\n20703 pts/3    00:00:01 node\n20722 pts/1    00:00:00 node\n20733 pts/1    00:00:18 node\n20796 pts/1    00:00:25 node\n20915 ?        00:00:00 init\n20916 ?        00:00:00 init\n20917 pts/4    00:00:00 bash\n20964 pts/4    00:00:00 python3\n20981 ?        00:00:00 init\n20982 ?        00:00:00 init\n20983 pts/5    00:00:00 bash\n21045 pts/5    00:00:00 ps\n</code></pre> <p>Terminal listings work the same as in regular markdown files.</p>"},{"location":"chapters/template-chapter/yet-another-topic/drills/","title":"Drills for Another Topic","text":"<p>Here we just reference questions.</p>"},{"location":"chapters/template-chapter/yet-another-topic/drills/questions/","title":"TODO question","text":""},{"location":"chapters/template-chapter/yet-another-topic/drills/questions/#question-text","title":"Question Text","text":"<p>Which answer is the correct answer?</p>"},{"location":"chapters/template-chapter/yet-another-topic/drills/questions/#question-answers","title":"Question Answers","text":"<ul> <li>Bad answer 1</li> <li>Correct answer</li> <li>Bad answer 2</li> <li>Bad answer 3</li> </ul>"},{"location":"chapters/template-chapter/yet-another-topic/drills/questions/#feedback","title":"Feedback","text":"<p>Correct answer is the correct answer</p> <pre><code>echo \"Guess why\"\n</code></pre>"},{"location":"chapters/tokens/lab/content/fungible-non-fungible/","title":"Fungible vs Non-Fungible Tokens","text":"<ul> <li>Fungibility refers to an asset's ability to be exchanged for something else of equal value;</li> <li>Some examples of fungible assets include currencies, commodities, and precious stones;</li> <li>Non-fungible assets are unique, requiring much more complex valuation before a sale and include things like real estate, art, and sports cards.</li> </ul> <p>Throughout the lab, you will need to convert values from decimals to hex to ascii, etc. Use this tool to make your job easier.</p>"},{"location":"chapters/tokens/lab/content/fungible-non-fungible/#practice","title":"Practice","text":"<p>Think about the following example if fungible or non-fungible:</p> <ul> <li>Diamond rock;</li> <li>Penthouse apartment in Manhattan;</li> <li>Mona Lisa painting;</li> <li>LeBron James sport card;</li> <li>LeBron James shirt he played in the 2020 NBA Finals;</li> <li>A character in World of Warcraft.</li> </ul>"},{"location":"chapters/tokens/lab/content/fungible/","title":"Fungible Tokens","text":""},{"location":"chapters/tokens/lab/content/fungible/#issuance-of-fungible-esdt-tokens-via-web-wallet-on-multiversx","title":"Issuance of fungible ESDT tokens via Web Wallet on MultiversX","text":"<p>In this section you will learn how to mint tokens on MultiversX.</p> <p>There are 2 types of tokens on MultiversX: * Native tokens - EGLD; * ESDT - eStandard Digital Token.</p> <p>In the previous section you learnt how to mint xEGLD on MultiversX Testnet using <code>Faucet</code> option.</p> <p></p>"},{"location":"chapters/tokens/lab/content/fungible/#mint-esdt-via-web-wallet","title":"Mint ESDT via Web Wallet","text":"<p>This time we use the <code>Create Token</code> option.</p> <p>Token Name: * length between 3 and 20 characters * alphanumeric characters only</p> <p>Token Ticker: * length between 3 and 10 characters * alphanumeric UPPERCASE only</p> <p>Number of decimals: * should be a numerical value between 0 and 18; * there are no floats on the blockchain; * a token with 3 decimals and value 1000 would be equal with value 1; * EGLD has 18 decimals and the value of 1000000000000000000 is 1 EGLD.</p> <p>Let's create a token new token:</p> <p></p> <p>and inspect the transaction </p> <p></p> <p>Observe <code>Token Operations</code> field. We received <code>321.00 BPDA-208994</code> tokens. <code>BPDA-208994</code> is the token ID. The token ID is formed by appending to the token ticker the character - and 6 random hexadecimals characters. This is done because there might be multiple tokens with the same ticker; the token ID is always unique.</p> <p>We can click on the token ID and see the details of the token:</p> <p></p> <p>Observe the fields TOKEN, Supply, Holders, Transactions, Owner, Decimals.</p> <p>Let create another token with the same input:</p> <p></p> <p>Observe that the token ID is different.</p>"},{"location":"chapters/tokens/lab/content/fungible/#practice","title":"Practice","text":"<ul> <li>Create your own ESDT token;</li> <li>Inspect the transaction;</li> <li>Send some of your tokens to erd1mqa9wttlzwwdvwgk9dzsfdn79lv5raw0tfe9ynvn0dg92hpruvaqhhd2gx;</li> <li>Create another token with the same ticker. Observer that the token ID is different and unique.</li> </ul>"},{"location":"chapters/tokens/lab/content/fungible/#issuance-of-fungible-esdt-tokens-via-cmdline-on-multiversx","title":"Issuance of fungible ESDT tokens via cmdline on MultiversX","text":"<p>Throughout the lab, you will need to convert values from decimals to hex to ascii, etc. Use this tool to make your job easier.</p> <p>ESDT tokens are issued via a request to the Metachain, which is a transaction submitted by the Account which will manage the tokens. When issuing a token, one must provide a token name, a ticker, the initial supply, the number of decimals for display purpose and optionally additional properties. The issuance cost is set to 0.05 EGLD.</p> <p>The receiver address erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u is a built-in system smart contract (not a VM-executable contract), which only handles token issuance and other token management operations, and does not handle any transfers. The contract will add a random string to the ticker thus creating the token identifier. The random string starts with \u201c-\u201d and has 6 more random characters (3 bytes - 6 characters hex encoded). For example, a token identifier could look like ALC-6258d2.</p> <p>Read more about issuance of fungible ESDT tokens here.</p>"},{"location":"chapters/tokens/lab/content/fungible/#issuance-example","title":"Issuance example:","text":"<pre><code>IssuanceTransaction {\n    Sender: &lt;account address of the token manager&gt;\n    Receiver: erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u\n    Value: 50000000000000000 # (0.05 EGLD)\n    GasLimit: 60000000\n    Data: \"issue\" +\n          \"@\" + &lt;token name in hexadecimal encoding&gt; +\n          \"@\" + &lt;token ticker in hexadecimal encoding&gt; +\n          \"@\" + &lt;initial supply in hexadecimal encoding&gt; +\n          \"@\" + &lt;number of decimals in hexadecimal encoding&gt;\n}\n</code></pre>"},{"location":"chapters/tokens/lab/content/fungible/#practice_1","title":"Practice","text":"<ul> <li>Issue a token of your own using <code>mxpy</code>. Choose whatever name and ticker you want. Check the existence of your token via Testnet Explorer.</li> </ul> <p>Hint: Use <code>mxpy --help</code></p>"},{"location":"chapters/tokens/lab/content/fungible/#mint-fungible-esdt-tokens-via-cmdline","title":"Mint fungible ESDT tokens via cmdline","text":"<p>NOTE</p> <p>Actions issue and mint are distinct! First, one must issue the token to exist on the blockchain. Second, the owner/issuer of the token must mint tokens.</p> <p>The transaction to mint tokens is: <pre><code>LocalMintTransaction {\n    Sender: &lt;address with ESDTRoleLocalMint role&gt;\n    Receiver: &lt;same as sender&gt;\n    Value: 0\n    GasLimit: 300000\n    Data: \"ESDTLocalMint\" +\n          \"@\" + &lt;token identifier in hexadecimal encoding&gt; +\n          \"@\" + &lt;supply to mint in hexadecimal encoding&gt;\n}\n</code></pre></p> <p>Note that the sender and the receiver are the same address, which is the creator of the token. After this transaction, he will receive in his wallet the minted tokens.</p>"},{"location":"chapters/tokens/lab/content/fungible/#practice_2","title":"Practice","text":"<ul> <li>Use the token created at the previous section to mint some tokens. Verify on the Testnet Explorer and in your wallet.</li> </ul>"},{"location":"chapters/tokens/lab/content/fungible/#setting-esdt-roles","title":"Setting ESDT Roles","text":"<p>Notice the Properties section in a Token page. </p> <p>There are several roles assigned to a token.  To change those roles we need to make a blockchain transaction: <pre><code>RolesAssigningTransaction {\n    Sender: &lt;address of the ESDT manager&gt;\n    Receiver: erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u\n    Value: 0\n    GasLimit: 60000000\n    Data: \"setSpecialRole\" +\n          \"@\" + &lt;token identifier in hexadecimal encoding&gt; +\n          \"@\" + &lt;address to assign the role(s) in a hexadecimal encoding&gt; +\n          \"@\" + &lt;role in hexadecimal encoding&gt; +\n          \"@\" + &lt;role in hexadecimal encoding&gt; +\n          ...\n}\n</code></pre></p>"},{"location":"chapters/tokens/lab/content/fungible/#practice_3","title":"Practice","text":"<ul> <li>Observe the roles of your newly created token.</li> <li>Add ESDTRoleLocalMint and ESDTRoleLocalBurn for your address.</li> <li>Mint 1000 tokens.</li> </ul> <p>You can read more about roles in the documentation.</p>"},{"location":"chapters/tokens/lab/content/fungible/#burning-esdt-tokens","title":"Burning ESDT Tokens","text":"<p>Anyone that holds an amount of ESDT tokens may burn it at their discretion, effectively losing them permanently. This operation reduces the total supply of tokens, and cannot be undone, unless the token manager mints more tokens.</p> <p>Do you have roles for burning?</p> <pre><code>LocalBurnTransaction {\n    Sender: &lt;address with ESDTRoleLocalBurn role&gt;\n    Receiver: &lt;same as sender&gt;\n    Value: 0\n    GasLimit: 300000\n    Data: \"ESDTLocalBurn\" +\n          \"@\" + &lt;token identifier in hexadecimal encoding&gt; +\n          \"@\" + &lt;supply to burn in hexadecimal encoding&gt;\n}\n</code></pre>"},{"location":"chapters/tokens/lab/content/fungible/#practice_4","title":"Practice","text":"<ul> <li>Burn 500 tokens</li> </ul>"},{"location":"chapters/tokens/lab/content/fungible/#other-actions-for-esdttokens","title":"Other actions for ESDTTokens","text":""},{"location":"chapters/tokens/lab/content/fungible/#pausing-and-unpausing","title":"Pausing and Unpausing","text":"<p>The manager of an ESDT token may choose to suspend all transactions of the token, except minting, freezing/unfreezing and wiping. Check more details here.</p>"},{"location":"chapters/tokens/lab/content/fungible/#freezing-and-unfreezing","title":"Freezing and Unfreezing","text":"<p>The manager of an ESDT token may freeze the tokens held by a specific Account. As a consequence, no tokens may be transferred to or from the frozen Account. Freezing and unfreezing the tokens of an Account are operations designed to help token managers to comply with regulations. The manager of an ESDT token may choose to suspend all transactions of the token, except minting, freezing/unfreezing and wiping. Check more details here.</p>"},{"location":"chapters/tokens/lab/content/fungible/#wiping","title":"Wiping","text":"<p>The manager of an ESDT token may wipe out all the tokens held by a frozen Account. This operation is similar to burning the tokens, but the Account must have been frozen beforehand, and it must be done by the token manager. Wiping the tokens of an Account is an operation designed to help token managers to comply with regulations. The manager of an ESDT token may choose to suspend all transactions of the token, except minting, freezing/unfreezing and wiping. Check more details here.</p>"},{"location":"chapters/tokens/lab/content/nft/","title":"Non-Fungible Tokens (NFTs)","text":"<p>These NFTs are unique, one-of-a-kind tokens that are built on blockchain technology, allowing for secure ownership and transfer of these assets. Every token is assigned a unique identification code(ticker) and metadata that distinguishes it from every other token.</p> <p>The flow of issuing and transferring non-fungible tokens is: * register/issue the token (this step creates an empty collection); * set roles to the address that will create the NFT/SFTs; * create the NFT/SFT; * transfer quantity(es).</p>"},{"location":"chapters/tokens/lab/content/nft/#issuance-of-nft-tokens","title":"Issuance of NFT tokens","text":"<p>One has to perform an issuance transaction in order to register a non-fungible token. Non-Fungible Tokens are issued via a request to the Metachain, which is a transaction submitted by the Account which will manage the tokens. When issuing a token, one must provide a token name, a ticker and optionally additional properties. This transaction has the form:</p> <pre><code>IssuanceTransaction {\n    Sender: &lt;account address of the token manager&gt;\n    Receiver: erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u\n    Value: 50000000000000000 # (0.05 EGLD)\n    GasLimit: 60000000\n    Data: \"issueNonFungible\" +\n          \"@\" + &lt;token name in hexadecimal encoding&gt; +\n          \"@\" + &lt;token ticker in hexadecimal encoding&gt;\n}\n</code></pre> <p>Optionally, the properties can be set when issuing a token. Example:</p> <pre><code>IssuanceTransaction {\n    Sender: &lt;account address of the token manager&gt;\n    Receiver: erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u\n    Value: 50000000000000000 # (0.05 EGLD)\n    GasLimit: 60000000\n    Data: \"issueNonFungible\" +\n          \"@\" + &lt;token name in hexadecimal encoding&gt; +\n          \"@\" + &lt;token ticker in hexadecimal encoding&gt; +\n          \"@\" + &lt;\"canFreeze\" hexadecimal encoded&gt; + \"@\" + &lt;\"true\" or \"false\" hexadecimal encoded&gt; +\n          \"@\" + &lt;\"canWipe\" hexadecimal encoded&gt; + \"@\" + &lt;\"true\" or \"false\" hexadecimal encoded&gt; +\n          \"@\" + &lt;\"canPause\" hexadecimal encoded&gt; + \"@\" + &lt;\"true\" or \"false\" hexadecimal encoded&gt; +\n          \"@\" + &lt;\"canTransferNFTCreateRole\" hexadecimal encoded&gt; + \"@\" + &lt;\"true\" or \"false\" hexadecimal encoded&gt; +\n          \"@\" + &lt;\"canChangeOwner\" hexadecimal encoded&gt; + \"@\" + &lt;\"true\" or \"false\" hexadecimal encoded&gt; +\n          \"@\" + &lt;\"canUpgrade\" hexadecimal encoded&gt; + \"@\" + &lt;\"true\" or \"false\" hexadecimal encoded&gt; +\n          \"@\" + &lt;\"canAddSpecialRoles\" hexadecimal encoded&gt; + \"@\" + &lt;\"true\" or \"false\" hexadecimal encoded&gt; +\n          ...\n}\n</code></pre>"},{"location":"chapters/tokens/lab/content/nft/#practice","title":"Practice","text":"<p>Let's create our first NFT collection. We will make a transaction to the testnet blockchain via mxpy tool. To install the tool check the prerequisites section.</p> <pre><code>costin@Byblos:~$ mxpy contract call erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u --pem ~/multiversX/keys/shard0.pem --proxy https://testnet-api.multiversx.com --chain T --recall-nonce --gas-limit 60000000 --value 50000000000000000 --function issueNonFungible --arguments 0x425044414578616d706c65546f6b656e 0x42504441  --send\n</code></pre> <p>We called that specific contract, signed with my pem to authenticate myself in the blockchain, used testnet proxy and chain, sent 0.05 EGLD, called issueNonFungible, using 2 parameters: * 0x425044414578616d706c65546f6b656e which is the name - BPDAExampleToken in hex; * 0x42504441 which is the ticker - BPDA in hex.</p> <p>Let's check our NFT collection on blockchain: </p> <p>Observe that the Collection Name (which is also known as token ID) is <code>BPDA-2d3d3c</code>. This is formed using the ticker provided,\"-\" and 6 random hex numbers. Also, observe the name BPDAExampleToken which is the one we provided. Lastly, observe that we have an empty collection, with no NFTs. </p>"},{"location":"chapters/tokens/lab/content/nft/#practice-your-turn","title":"Practice - your turn","text":"<ul> <li>Create an NFT collection.</li> </ul>"},{"location":"chapters/tokens/lab/content/nft/#assigning-roles-to-an-nft-collection","title":"Assigning roles to an NFT Collection","text":"<p>Roles can be assigned by sending a transaction to the Metachain from the ESDT manager. Within a transaction of this kind, any number of roles can be assigned (minimum 1).</p> <pre><code>RolesAssigningTransaction {\n    Sender: &lt;address of the ESDT manager&gt;\n    Receiver: erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u\n    Value: 0\n    GasLimit: 60000000\n    Data: \"setSpecialRole\" +\n          \"@\" + &lt;token identifier in hexadecimal encoding&gt; +\n          \"@\" + &lt;address to assign the role(s) in a hexadecimal encoding&gt; +\n          \"@\" + &lt;role in hexadecimal encoding&gt; +\n          \"@\" + &lt;role in hexadecimal encoding&gt; +\n          ...\n}\n</code></pre> <p>Don't forget to convert the values to hex. For example, <code>ESDTRoleNFTCreate = 0x45534454526f6c654e4654437265617465</code>.</p>"},{"location":"chapters/tokens/lab/content/nft/#nft-fields","title":"NFT fields","text":"<p>Below you can find the fields involved when creating an NFT: * NFT Name     * The name of the NFT or SFT; * Quantity      * The quantity of the token. If NFT, it must be 1;     * There are Semi-Fungible Tokens (SFT). You can read more here; * Royalties - Allows the creator to receive royalties for any transaction involving their NFT     * Allows the creator to receive royalties for any transaction involving their NFT;     * Base format is a numeric value between 0 an 10000 (0 meaning 0% and 10000 meaning 100%) * Hash     * Arbitrary field that should contain the hash of the NFT metadata;     * Optional filed, should be left null when building the transaction to create the NFT; * Attributes     * Represents additional information about the NFT or SFT, like picture traits or tags for your NFT/collection;     * The field should follow a <code>metadata:ipfsCID/fileName.json;tags:tag1,tag2,tag3</code> format;     * Below you can find a sample for the extra metadata format that should be stored on IPFS:</p> <p><pre><code>{\n  \"description\": \"This is a sample description\",\n  \"attributes\": [\n    {\n      \"trait_type\": \"Background\",\n      \"value\": \"Yellow\",\n      \"{key}\": \"{value}\",\n      \"{...}\": \"{...}\",\n      \"{key}\": \"{value}\"\n    },\n    {\n      \"trait_type\": \"Headwear\",\n      \"value\": \"BlackBeanie\"\n    },\n    {\n      \"trait_type\": \"SampleTrait3\",\n      \"value\": \"SampleValue3\"\n    }\n  ],\n  \"collection\": \"ipfsCID/fileName.json\"\n}\n</code></pre> * URI(s)     * Mandatory field that represents the URL to a supported media file ending with the file extension as described in the example below;     * Field should contain the Uniform Resource Identifier;</p> <p>NOTE</p> <p>Please note that each argument must be encoded in hexadecimal format with an even number of characters.</p>"},{"location":"chapters/tokens/lab/content/nft/#creation-of-an-nft","title":"Creation of an NFT","text":"<p>A single address can own the role of creating an NFT for an ESDT token. This role can be transferred by using the ESDTNFTCreateRoleTransfer function.</p> <p>An NFT can be created on top of an existing ESDT by sending a transaction to self that contains the function call that triggers the creation. Any number of URIs can be assigned (minimum 1).</p> <pre><code>NFTCreationTransaction {\n    Sender: &lt;address with ESDTRoleNFTCreate role&gt;\n    Receiver: &lt;same as sender&gt;\n    Value: 0\n    GasLimit: 3000000 + Additional gas (see below)\n    Data: \"ESDTNFTCreate\" +\n          \"@\" + &lt;token identifier in hexadecimal encoding&gt; +\n          \"@\" + &lt;initial quantity in hexadecimal encoding&gt; +\n          \"@\" + &lt;NFT name in hexadecimal encoding&gt; +\n          \"@\" + &lt;Royalties in hexadecimal encoding&gt; +\n          \"@\" + &lt;Hash in hexadecimal encoding&gt; +\n          \"@\" + &lt;Attributes in hexadecimal encoding&gt; +\n          \"@\" + &lt;URI in hexadecimal encoding&gt; +\n          \"@\" + &lt;URI in hexadecimal encoding&gt; +\n          ...\n}\n</code></pre> <p>Additional gas refers to: * Transaction payload cost: <code>Data field length * 1500</code> (GasPerDataByte = 1500); * Storage cost: <code>Size of NFT data * 50000</code> (StorePerByte = 50000).</p>"},{"location":"chapters/tokens/lab/content/nft/#transfer-nft-creation-role","title":"Transfer NFT Creation Role","text":"<p>The role of creating an NFT can be transferred by a Transaction like this: <pre><code>TransferCreationRoleTransaction {\n    Sender: &lt;address of the current creation role owner&gt;\n    Receiver: erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u\n    Value: 0\n    GasLimit: 60000000 + length of Data field in bytes * 1500\n    Data: \"transferNFTCreateRole\" +\n          \"@\" + &lt;token identifier in hexadecimal encoding&gt; +\n          \"@\" + &lt;the address to transfer the role from in hexadecimal encoding&gt; +\n          \"@\" + &lt;the address to transfer the role to in hexadecimal encoding&gt;\n}\n</code></pre></p>"},{"location":"chapters/tokens/lab/content/nft/#change-nft-attributes","title":"Change NFT Attributes","text":"<p>An user that has the `ESDTRoleNFTUpdateAttributes`` role set for a given ESDT, can change the attributes of a given NFT/SFT.</p> <p>NOTE</p> <p><code>ESDTNFTUpdateAttributes</code> will remove the old attributes and add the new ones. Therefore, if you want to keep the old attributes you will have to pass them along with the new ones.</p> <p>This is done by performing a transaction like this:</p> <pre><code>ESDTNFTUpdateAttributesTransaction {\n    Sender: &lt;address of an address that has ESDTRoleNFTUpdateAttributes role&gt;\n    Receiver: &lt;same as sender&gt;\n    Value: 0\n    GasLimit: 10000000\n    Data: \"ESDTNFTUpdateAttributes\" +\n          \"@\" + &lt;token identifier in hexadecimal encoding&gt; +\n          \"@\" + &lt;NFT or SFT nonce in hexadecimal encoding&gt; +\n          \"@\" + &lt;Attributes in hexadecimal encoding&gt;\n}\n</code></pre>"},{"location":"chapters/tokens/lab/content/nft/#transfers","title":"Transfers","text":"<p>Performing an ESDT NFT transfer is done by specifying the receiver's address inside the Data field, alongside other details. An ESDT NFT transfer transaction has the following form:</p> <pre><code>TransferTransaction {\n    Sender: &lt;account address of the sender&gt;\n    Receiver: &lt;same as sender&gt;\n    Value: 0\n    GasLimit: 1000000 + length of Data field in bytes * 1500\n    Data: \"ESDTNFTTransfer\" +\n          \"@\" + &lt;collection identifier in hexadecimal encoding&gt; +\n          \"@\" + &lt;the NFT nonce in hexadecimal encoding&gt; +\n          \"@\" + &lt;quantity to transfer in hexadecimal encoding&gt; +\n          \"@\" + &lt;destination address in hexadecimal encoding&gt;\n}\n</code></pre>"},{"location":"chapters/tokens/lab/content/nft/#branding","title":"Branding","text":"<p>Here is <code>SubcarpatiOGs</code> NFT Collection. </p> <p>Observe that there are Social links, a Description and you can even see a Logo.</p> <p>For branding you NFT collection please read the instructions.</p>"},{"location":"chapters/tokens/lab/content/standards/","title":"Token Standards","text":"<p>A crypto token is a representation of an asset or interest that has been tokenized on an existing cryptocurrency's blockchain. Crypto tokens and cryptocurrencies share many similarities, but cryptocurrencies are intended to be used as a medium of exchange, a means of payment, and a measure and store of value.</p> <p>Crypto tokens are often used to raise funds for projects and are usually created, distributed, sold, and circulated through an initial coin offering (ICO) process, which involves a crowdfunding round.</p> <p>In this section we will discuss 2 different approaches of token implementation: * Ethereum Standard: ERC - Ethereum Request for Comments * MultiversX: ESDT - eStandard Digital Token</p>"},{"location":"chapters/tokens/lab/content/standards/#erc-ethereum-request-for-comments","title":"ERC - Ethereum Request for Comments","text":"<p>ERC (Ethereum Request for Comments) standards provide a set of guidelines and specifications for creating and implementing smart contracts, tokens, and other blockchain-based applications on the Ethereum network. ERCs are a set of technical standards that are used to create and manage tokens on the Ethereum blockchain. ERC standards define a set of rules and protocols that tokens must follow in order to be compatible with the Ethereum network. These rules cover a variety of aspects, such as token transfer functions, token ownership, and smart contract security. By following these standards, developers can ensure that their tokens are interoperable with other tokens and can be easily exchanged on the Ethereum network.</p> <p>There are currently several ERC standards, including ERC-20, ERC-721, ERC-777, and ERC-1155, each of which has a specific set of features and functions. ERC-20 is the most widely used token standard and is used to create fungible tokens, while ERC-721 is used to create non-fungible tokens (NFTs). Other ERC standards, such as ERC-777 and ERC-1155, provide additional features and functions for creating more complex tokens.</p> <p>You can read more about ERC-20 and ERC-721.</p> <p>Here are the top Ethereum tokens.</p>"},{"location":"chapters/tokens/lab/content/standards/#esdt-estandard-digital-token","title":"ESDT - eStandard Digital Token","text":"<p>The MultiversX network natively supports the issuance of custom tokens, without the need for contracts such as ERC20, but addressing the same use-cases. And due to the native in-protocol support, transactions with custom tokens do not require the VM at all.</p> <p>Technically, the balances of ESDT tokens held by an Account are stored directly under the data trie of that Account. It also implies that an Account can hold balances of any number of custom tokens, in addition to the native EGLD balance. The protocol guarantees that no Account can modify the storage of ESDT tokens, neither its own nor of other Accounts.</p> <p>ESDT tokens can be issued, owned and held by any Account on the MultiversX network, which means that both users and smart contracts have the same functionality available to them.</p>"},{"location":"chapters/tokens/lab/content/standards/#differences-between-erc-and-esdt","title":"Differences between ERC and ESDT","text":"<p>The first difference we observe is that ERC standards are smart contracts deployed on blockchain while ESDTs are tokens assigned to users. In ERC user balances are stored in the Smart Contract while in ESDT balances are stored in users' wallets.</p> <p>Here are the top MultiversX tokens.</p>"},{"location":"chapters/vm/lab/content/vm/","title":"VM","text":""},{"location":"chapters/vm/lab/content/vm/#inspect-sc-calls-from-observers-logs","title":"Inspect SC calls from observer\u2019s logs","text":"<p>TODO</p>"},{"location":"chapters/vm/lab/content/vm/#run-locally-a-sc-call","title":"Run locally a SC call","text":"<p>TODO</p>"},{"location":"util/grading/","title":"Grading","text":"Section Percent of total grade Lab involvement 10p Homework 1 15p Homework 2 15p Project 20p 35p Lecture involvement 10p (bonus) Practical final exam 30p  points Theoretical final exam 10p  points Total 110p <p>4.5 points are required to pass the class. There are no other requirements (such as a minimal grade for a given component).</p> <p>In case you don't pass the exam you may choose to keep the lab and assignments grade or the final exam grade for the next year. You cannot keep some parts of these grades. If choosing not to keep any grade, everything will be reset for at the beginning of the 2025-2026 academic year.</p>"},{"location":"util/grading/#practical-exam","title":"Practical Exam","text":"<ul> <li>Open Book - you can access any online/offline resources as long as you don't collaborate;</li> <li>60 minutes;</li> <li>Some of the tasks you will have to do: create a wallet, write a basic smart contract, build and deploy it, interact with it (make transactions on the blockchain with the SC you deployed), use events for SC, create fungible and non-fungible tokens;</li> <li>You can prepare and use any scripts for interaction with the blockchain;</li> <li>Can be solved on any blockchain you want;</li> </ul>"},{"location":"util/grading/#theoretical-exam","title":"Theoretical Exam","text":"<ul> <li>Closed Book - access to any online/offline resources is considered cheating;</li> <li>15 minutes;</li> <li>The exam will take place on Moodle.</li> </ul>"},{"location":"util/resources/","title":"Resources and Useful Links","text":""},{"location":"util/resources/#list-of-resources","title":"List of Resources:","text":"<ul> <li>GitHub Repository</li> <li>Moodle Class (used for homework submissions, quizzes, announcements, etc.)</li> <li>Planning</li> </ul>"},{"location":"util/resources/#books-and-interesting-reading-materials","title":"Books and interesting reading materials","text":"<ul> <li>Foundations of Distributed Consensus and Blockchains - must read book for blockchain protocol enthusiasts;</li> <li>Implications of Open Monetary and Information Networks - read to form an intuition about the need for blockchain and decentralized solutions;</li> <li>Bitcoin Whitepaper;</li> <li>Ethereum Whitepaper;</li> <li>MultiversX Whitepaper;</li> <li>State of Crypto</li> <li>Step by step guide to becoming a blockchain developer in 2024;</li> <li>Secure Development Workflow for Smart Contracts;</li> <li>DeFi Handbook \u2014 Introduction to Decentralized Finance</li> <li>Cryptozombies learning game</li> <li>The Rust Programming Language</li> <li>Rust by Example</li> <li>Improving the Rust Book (really interactive)</li> <li>Solidity docs</li> </ul>"},{"location":"util/resources/#virtual-machine","title":"Virtual Machine","text":"<p>You can use any Linux environment (native install, <code>WSL</code>, virtual machine, docker environment, etc.) for the OS class. We provide Linux virtual machines with all the setup ready.</p>"},{"location":"util/resources/#virtualbox-vmware","title":"VirtualBox / VMware","text":"<p>You can download the Linux virtual machine from this link.</p> <p>You can import the <code>.ova</code> file in VirtualBox or VMware. Follow the instructions on the official websites for installation.</p>"},{"location":"util/resources/#utm-macos-11","title":"UTM (macOS &gt;= 11)","text":"<p>If you are using an <code>M1</code> Apple system, you will not be able to run the virtual machine using VirtualBox or VMware. You will need to use <code>UTM</code>, along with a <code>.qcow2</code> image.</p> <p>After you install <code>UTM</code> and download and unzip the archive, you can import it using the <code>Open existing VM</code> option in <code>UTM</code>.</p> <p>You can also follow the instructions for running the VM using <code>qemu</code>.</p>"}]}
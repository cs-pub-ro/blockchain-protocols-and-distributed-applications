"use strict";(globalThis.webpackChunkbpda=globalThis.webpackChunkbpda||[]).push([[5047],{5680(e,n,i){i.d(n,{xA:()=>c,yg:()=>d});var t=i(6540);function a(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function r(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),i.push.apply(i,t)}return i}function o(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?r(Object(i),!0).forEach(function(n){a(e,n,i[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))})}return e}function l(e,n){if(null==e)return{};var i,t,a=function(e,n){if(null==e)return{};var i,t,a={},r=Object.keys(e);for(t=0;t<r.length;t++)i=r[t],n.indexOf(i)>=0||(a[i]=e[i]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)i=r[t],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var s=t.createContext({}),m=function(e){var n=t.useContext(s),i=n;return e&&(i="function"==typeof e?e(n):o(o({},n),e)),i},c=function(e){var n=m(e.components);return t.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},g=t.forwardRef(function(e,n){var i=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),g=m(i),d=a,u=g["".concat(s,".").concat(d)]||g[d]||p[d]||r;return i?t.createElement(u,o(o({ref:n},c),{},{components:i})):t.createElement(u,o({ref:n},c))});function d(e,n){var i=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=i.length,o=new Array(r);o[0]=g;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var m=2;m<r;m++)o[m]=i[m];return t.createElement.apply(null,o)}return t.createElement.apply(null,i)}g.displayName="MDXCreateElement"},9534(e,n,i){i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>m});var t=i(8168),a=(i(6540),i(5680));const r={},o="The Adder SC",l={unversionedId:"Practical Sessions/Smart Contracts/adder",id:"Practical Sessions/Smart Contracts/adder",title:"The Adder SC",description:"The Adder smart contract is a simple smart contract with an add functionality and a global variable that can be incremented.",source:"@site/docs/Practical Sessions/Smart Contracts/adder.md",sourceDirName:"Practical Sessions/Smart Contracts",slug:"/Practical Sessions/Smart Contracts/adder",permalink:"/blockchain-protocols-and-distributed-applications/Practical Sessions/Smart Contracts/adder",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Empty Interaction",permalink:"/blockchain-protocols-and-distributed-applications/Practical Sessions/Smart Contracts/empty_interaction"},next:{title:"Smart Contract deployment via Rust",permalink:"/blockchain-protocols-and-distributed-applications/Practical Sessions/Smart Contracts/adder_rust_interaction"}},s={},m=[{value:"Practice",id:"practice",level:2}],c={toc:m};function p({components:e,...n}){return(0,a.yg)("wrapper",(0,t.A)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"the-adder-sc"},"The Adder SC"),(0,a.yg)("p",null,"The Adder smart contract is a simple smart contract with an ",(0,a.yg)("inlineCode",{parentName:"p"},"add")," functionality and a global variable that can be incremented."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust"},'/// One of the simplest smart contracts possible,\n/// it holds a single variable in storage, which anyone can increment.\n#[multiversx_sc::contract]\npub trait Adder {\n    #[view(getSum)]\n    #[storage_mapper("sum")]\n    fn sum(&self) -> SingleValueMapper<BigUint>;\n\n    #[init]\n    fn init(&self, initial_value: BigUint) {\n        self.sum().set(initial_value);\n    }\n\n    #[upgrade]\n    fn upgrade(&self, initial_value: BigUint) {\n        self.init(initial_value);\n    }\n\n    /// Add desired amount to the storage variable.\n    #[endpoint]\n    fn add(&self, value: BigUint) {\n        self.sum().update(|sum| *sum += value);\n    }\n}\n')),(0,a.yg)("p",null,"We notice 4 functions:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"sum")," - this is a global variable, a ",(0,a.yg)("inlineCode",{parentName:"li"},"SingleValueMapper")," (a single value) of type BigUint (unsigned integer);"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"init")," - the constructor;"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"add")," - function that increments the global variable (",(0,a.yg)("inlineCode",{parentName:"li"},"sum"),") with the ",(0,a.yg)("inlineCode",{parentName:"li"},"value")," parameter;"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"upgrade")," - function executed when upgrading the contract.")),(0,a.yg)("p",null,"We notice 5 types of annotations:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"#[view(getSum)]")," - this is a function that allows you to read the storage variable by calling the function ",(0,a.yg)("inlineCode",{parentName:"li"},"getSum"),";"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},'#[storage_mapper("sum")]')," - this is a global ",(0,a.yg)("strong",{parentName:"li"},"variable")," (also called a storage) stored at the contract address;"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"#[init]")," - the constructor function; this is called when deploying the contract;"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"#[upgrade]"),"  - this function is called when upgrading the contract;"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"#[endpoint]")," - an endpoint is a function callable directly by the user; A function not having this annotation will not be exposed publicly.")),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://github.com/multiversx/mx-contracts-rs/blob/main/contracts/adder/src/adder.rs"},"Here")," is the smart contract code listed above and ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/multiversx/mx-contracts-rs/tree/main/contracts/adder"},"here")," are all the files needed for compilation."),(0,a.yg)("p",null,"You can obtain the adder smart contract code directly using the following command:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"sc-meta new --template adder\n")),(0,a.yg)("p",null,"Let's build the smart contract, running the next command in the contract root:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-sh"},"sc-meta all build\n")),(0,a.yg)("p",null,"Below, it is the output of the command:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},' /home/adder\n\nFound 1 contract crates.\n\n(1/1)\nIn /home/adder/meta\nCalling `cargo run build`\n   Compiling syn v2.0.110\n   Compiling serde_core v1.0.228\n   Compiling num-traits v0.2.19\n   Compiling bitflags v2.10.0\n   Compiling hex v0.4.3\n   Compiling equivalent v1.0.2\n   Compiling utf8parse v0.2.2\n   Compiling unwrap-infallible v0.1.5\n   Compiling hashbrown v0.16.0\n   Compiling arrayvec v0.7.6\n   Compiling typenum v1.19.0\n   Compiling semver v1.0.27\n   Compiling anstyle-query v1.1.4\n   Compiling memchr v2.7.6\n   Compiling anstyle-parse v0.2.7\n   Compiling colorchoice v1.0.4\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling leb128fmt v0.1.0\n   Compiling foldhash v0.1.5\n   Compiling anstyle v1.0.13\n   Compiling unicode-width v0.2.2\n   Compiling serde_json v1.0.145\n   Compiling wasm-encoder v0.240.0\n   Compiling winnow v0.7.13\n   Compiling hex-literal v1.1.0\n   Compiling anstream v0.6.21\n   Compiling strsim v0.11.1\n   Compiling bumpalo v3.19.0\n   Compiling clap_lex v0.7.6\n   Compiling anyhow v1.0.100\n   Compiling ryu v1.0.20\n   Compiling clap_builder v4.5.51\n   Compiling toml_writer v1.0.4\n   Compiling generic-array v1.3.5\n   Compiling itoa v1.0.15\n   Compiling unicode-segmentation v1.12.0\n   Compiling termcolor v1.4.1\n   Compiling rustc_version v0.4.1\n   Compiling lazy_static v1.5.0\n   Compiling colored v3.0.0\n   Compiling num-integer v0.1.46\n   Compiling convert_case v0.8.0\n   Compiling num-bigint v0.4.6\n   Compiling wast v240.0.0\n   Compiling toml_parser v1.0.4\n   Compiling indexmap v2.12.0\n   Compiling serde_spanned v1.0.3\n   Compiling toml_datetime v0.7.3\n   Compiling toml v0.9.8\n   Compiling multiversx-sc-codec-derive v0.23.1\n   Compiling serde_derive v1.0.228\n   Compiling multiversx-sc-derive v0.62.1\n   Compiling clap_derive v4.5.49\n   Compiling multiversx-sc-codec v0.23.1\n   Compiling clap v4.5.51\n   Compiling multiversx-chain-core v0.19.1\n   Compiling multiversx-sc v0.62.1\n   Compiling serde v1.0.228\n   Compiling hashbrown v0.15.5\n   Compiling wat v1.240.0\n   Compiling wasmparser v0.239.0\n   Compiling adder v0.0.0 (/home/adder)\n   Compiling wasmprinter v0.239.0\n   Compiling multiversx-sc-meta-lib v0.62.1\n   Compiling adder-meta v0.0.0 (/home/adder/meta)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 13.82s\n     Running `/home/adder/target/debug/adder-meta build`\nUsing workspace target directory: /home/adder/target ...\nBuilding adder.wasm in /home/adder/wasm ...\nRUSTFLAGS="-C link-arg=-s -C link-arg=-zstack-size=131072" cargo build --target=wasm32v1-none --release --target-dir /home/adder/target\n    Updating crates.io index\n    Blocking waiting for file lock on package cache\n     Locking 25 packages to latest compatible versions\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.42\n   Compiling hex v0.4.3\n   Compiling smallvec v1.15.1\n   Compiling typenum v1.19.0\n   Compiling rustversion v1.0.22\n   Compiling autocfg v1.5.0\n   Compiling bitflags v2.10.0\n   Compiling endian-type v0.2.0\n   Compiling unwrap-infallible v0.1.5\n   Compiling arrayvec v0.7.6\n   Compiling hex-literal v1.1.0\n   Compiling num-traits v0.2.19\n   Compiling nibble_vec v0.1.0\n   Compiling radix_trie v0.3.0\n   Compiling syn v2.0.110\n   Compiling generic-array v1.3.5\n   Compiling multiversx-sc-codec-derive v0.23.1\n   Compiling multiversx-sc-derive v0.62.1\n   Compiling multiversx-sc-codec v0.23.1\n   Compiling multiversx-chain-core v0.19.1\n   Compiling multiversx-sc v0.62.1\n   Compiling adder v0.0.0 (/home/adder)\n   Compiling multiversx-sc-wasm-adapter v0.62.1\n   Compiling adder-wasm v0.0.0 (/home/adder/wasm)\n    Finished `release` profile [optimized] target(s) in 8.55s\nCopying /home/adder/target/wasm32v1-none/release/adder_wasm.wasm to ../output/adder.wasm ...\nCalling wasm-opt on ../output/adder.wasm ...\nExtracting imports to ../output/adder.imports.json ...\nChecking EI version: 1.5 ... OK\nPacking ../output/adder.mxsc.json ...\nContract size: 700 bytes.\n')),(0,a.yg)("p",null,"Let's check the contract:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"ls -l output/\ntotal 16\n-rw-rw-r-- 1 user user 1727 nov 13 15:09 adder.abi.json\n-rw-rw-r-- 1 user user  262 nov 13 15:09 adder.imports.json\n-rw-rw-r-- 1 user user 4078 nov 13 15:09 adder.mxsc.json\n-rwxrwxr-x 1 user user  700 nov 13 15:09 adder.wasm\n")),(0,a.yg)("p",null,"We notice that the resulted contract (",(0,a.yg)("inlineCode",{parentName:"p"},"adder.wasm"),") has 700 bytes."),(0,a.yg)("h2",{id:"practice"},"Practice"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Compile the Adder contract.")))}p.isMDXComponent=!0}}]);
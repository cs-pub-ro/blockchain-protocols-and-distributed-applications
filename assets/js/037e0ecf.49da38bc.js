"use strict";(self.webpackChunkblockchain_protocols_and_distributed_applications=self.webpackChunkblockchain_protocols_and_distributed_applications||[]).push([[5214],{295:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>f,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var r=t(8168),a=(t(6540),t(5680));const s={},o="CTF GasPass",l={unversionedId:"Practical Sessions/CTF/gaspass",id:"Practical Sessions/CTF/gaspass",title:"CTF GasPass",description:"Let's see who can get at least one point!",source:"@site/docs/Practical Sessions/CTF/gaspass.md",sourceDirName:"Practical Sessions/CTF",slug:"/Practical Sessions/CTF/gaspass",permalink:"/workshop-blockchain-protocols-and-distributed-applications/Practical Sessions/CTF/gaspass",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"CTF Coinflip",permalink:"/workshop-blockchain-protocols-and-distributed-applications/Practical Sessions/CTF/coinflip"},next:{title:"Observer (Extra)",permalink:"/workshop-blockchain-protocols-and-distributed-applications/Practical Sessions/Observer (Extra)/"}},i={},c=[],p={toc:c},u="wrapper";function f(e){let{components:n,...t}=e;return(0,a.yg)(u,(0,r.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"ctf-gaspass"},"CTF GasPass"),(0,a.yg)("p",null,"Let's see who can get at least one point!"),(0,a.yg)("p",null,"There is one obstacle, though: you must provide the exact value for gas to get even one single point. What should this value be?"),(0,a.yg)("p",null,"Brute force is always an option, but maybe some of you will find a quicker way?"),(0,a.yg)("p",null,"Once you get the correct value for gas, the problem becomes identical to ",(0,a.yg)("inlineCode",{parentName:"p"},"bump"),", so 1 point in this round is enough to prove your worth!"),(0,a.yg)("p",null,"For this challenge you will get the full code:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-Rust"},'#[multiversx_sc::contract]\npub trait CtfGaspass: bump_common::BumpCommon {\n    #[init]\n    fn init(&self) {}\n\n    #[upgrade]\n    fn upgrade(&self) {}\n\n    #[endpoint]\n    fn gaspass(&self) -> bool {\n        let gas_left = self.blockchain().get_gas_left();\n        let caller = self.blockchain().get_caller();\n        let the_key = KEY_BASELINE + self.personal_key(&caller);\n        let passed = gas_left == the_key;\n\n        if passed {\n            self.perform_bump(&caller);\n        } else {\n            self.bumps(&caller).clear();\n        };\n        self.gaspass_event(&caller, passed);\n        passed\n    }\n\n    fn personal_key(&self, caller: &ManagedAddress) -> u64 {\n        let bytes = caller.to_byte_array();\n        bytes.iter().map(|&b| b as u64).sum()\n    }\n\n    #[event("gaspass")]\n    fn gaspass_event(&self, #[indexed] caller: &ManagedAddress, #[indexed] passed: bool);\n\n    fn perform_bump(&self, bumper: &ManagedAddress) {\n        self.bumps(bumper).update(|bumps| *bumps += 1u32);\n    }\n\n    #[view]\n    #[storage_mapper("bumps")]\n    fn bumps(&self, bumper: &ManagedAddress) -> SingleValueMapper<BigUint>;\n}\n')),(0,a.yg)("p",null,"Enjoy your hacking!"))}f.isMDXComponent=!0},5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>g});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var i=r.createContext({}),c=function(e){var n=r.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(i.Provider,{value:n},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(t),d=a,g=u["".concat(i,".").concat(d)]||u[d]||f[d]||s;return t?r.createElement(g,o(o({ref:n},p),{},{components:t})):r.createElement(g,o({ref:n},p))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,o=new Array(s);o[0]=d;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var c=2;c<s;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);